{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocs-macros A plugin for unleashing the power of Mkdocs , by using variables and macros. A mini-framework mkdocs-macros is more than a \"plugin\". It is a mini-framework developped with one goal in mind: To enhance mkdocs with the macro and automation capabilities available to a wiki engine . 1 For more information, see Why this project? Overview Definition mkdocs-macros-plugin is a plugin/framework that makes it easy for contributors of an MkDocs website to produce richer and more beautiful pages. It can do two things: Transforming the markdown pages into Jinja2 templates that: Use environment or custom variables , Call pre-defined or custom macros , Exploit standard or custom filters Replacing MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the html pages have already been generated etc. The capabilities of mkdocs-macros-plugin are such that it can be called a \"mini-framework\" . mkdocs-macros-plugin is very easy to use out of the box , even for small documentation projects: it provides data about the platform, the git repository (if any), etc. Variables Regular variables are loaded with each markdown page which is being rendered. Variables can be defined in five different ways: Global , i.e. for the whole documentation project: (for designers of the website): in the mkdocs.yml file, under the extra heading (for contributors): in external yaml definition files (for programmers): in a module (Python), by adding them to a dictionary Local , i.e. in each Markdown page (for contributors): in the YAML header in the text, with a {%set variable = value %} statement Enrich markdown with templating You can leverage the power of Python in markdown thanks to jinja2 by writing this : The unit price of product A is {{ unit_price }} EUR. Taking the standard discount into account, the sale price of 50 units is {{ price(unit_price, 50) }} EUR. If you defined a price() function, this could translate into: The unit price of product A is 10.00 EUR. Taking the standard discount into account, the sale price of 50 units is 450.00 EUR. It is possible to use the wide range of facilities provided by Jinja2 templates . Create Your Own Macros and Filters Instead of creating countless new plugins, programmers can define their macros and filters . Getting Started with Macros Need a function to display some repetitive markdown, or environment information? If you are a Python programmer, go ahead and create your own macros and filters in Python! It's actually much, much easier than writing a VBA function for Excel... Create a main.py file in the top directory of your mkdocs project and add this call: import ... def define_env(env): \"Hook function\" @env.macro def mymacro(...) ... return some_string You can insert a call in any markdown page of your project: {{ mymacro(...) }} Restart your mkdocs server. Et voil\u00e0 ! Producing HTML The result of a macro can also be HTML code : this makes macros especially useful to make custom extensions to the syntax of markdown, such as buttons, calls to email, embedding YouTube videos, etc. Boosting large or complex documentation projects mkdocs-macros was also developed with large or complex projects in mind . You can include separate configurations files, import Jinja2 macro definitions, add \"post-production\" elements to your website, etc. You can go all the way as to pre-package modules into pluglets that can be installed as Python packages. Note By using mkdocs-macros, you can cut down the number of plugins required for your documentation project. In a wide range of cases, writing your own module with macros (Python functions for a single website), could save the effort of developing new plugins for mkdocs . Installation Prerequisites Python version > 3.5 MkDocs version >= 1.0 (it should work > 0.17 (it should be compatible with post 1.0 versions) Standard installation pip install mkdocs-macros-plugin If you wish to also run the tests or rebuild the project's documentation: pip install 'mkdocs-macros-plugin[test]' \"Manual installation\" To install the package, download the code from its github page and run: python setup.py install Declaration of the macros plugin Declare the plugin in the the file mkdocs.yml : plugins: - search - macros Warning If you are creating the plugins entry in your config file, you should also insert a line for the search plugin. In the absence of the plugins entry, MkDocs enables search by default. But when it is present, then you MUST declare it explicitly if you want to use it. Check that it works Tip The recommended way to check that the plugin works properly is to add the following command in one of the pages of your site (let's say info.md ): {{ macros_info() }} In the terminal, restart the environment: > mkdocs serve You will notice that additional information now appears in the terminal: INFO - Building documentation... [macros] Macros arguments: {'module_name': 'main', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': ''} Within the browser (e.g. http://127.0.0.1:8000/info), you should see a description of the plugins environment: If you see it that information, you should be all set. Give a good look at the General List, since it gives you an overview of what you can do out of the box with the macros plugin. The other parts give you more detailed information. Configuration of the plugin Here are all the possible arguments in the plugin section of the MkDocs' config file: Argument Default Description module_name main Name of the Python module containing macros, filters and variables. Indicate the file or directory, without extension; you may specify a path (e.g. include/module ). If no main module is available, it is ignored. modules [] List of preinstalled Python modules , i.e. listed by pip list . include_dir Directory for including external files include_yaml [] List of yaml files or key: filename pairs to be included j2_block_start_string Non-standard Jinja2 marker for start of block j2_block_end_string Non-standard Jinja2 marker for end of block j2_variable_start_string Non-standard Jinja2 marker for start of variable j2_variable_end_string Non-standard Jinja2 marker for end of variable For example: plugins: - search - macros: module_name: mymodule include_dir: include With reference to existing wiki engines such as Dokuwiki or Atlassian Confluence . \u21a9","title":"Home"},{"location":"#mkdocs-macros","text":"A plugin for unleashing the power of Mkdocs , by using variables and macros. A mini-framework mkdocs-macros is more than a \"plugin\". It is a mini-framework developped with one goal in mind: To enhance mkdocs with the macro and automation capabilities available to a wiki engine . 1 For more information, see Why this project?","title":"mkdocs-macros"},{"location":"#overview","text":"","title":"Overview"},{"location":"#definition","text":"mkdocs-macros-plugin is a plugin/framework that makes it easy for contributors of an MkDocs website to produce richer and more beautiful pages. It can do two things: Transforming the markdown pages into Jinja2 templates that: Use environment or custom variables , Call pre-defined or custom macros , Exploit standard or custom filters Replacing MkDocs plugins for a wide range of tasks: e.g. manipulating the navigation, adding files after the html pages have already been generated etc. The capabilities of mkdocs-macros-plugin are such that it can be called a \"mini-framework\" . mkdocs-macros-plugin is very easy to use out of the box , even for small documentation projects: it provides data about the platform, the git repository (if any), etc.","title":"Definition"},{"location":"#variables","text":"Regular variables are loaded with each markdown page which is being rendered. Variables can be defined in five different ways: Global , i.e. for the whole documentation project: (for designers of the website): in the mkdocs.yml file, under the extra heading (for contributors): in external yaml definition files (for programmers): in a module (Python), by adding them to a dictionary Local , i.e. in each Markdown page (for contributors): in the YAML header in the text, with a {%set variable = value %} statement","title":"Variables"},{"location":"#enrich-markdown-with-templating","text":"You can leverage the power of Python in markdown thanks to jinja2 by writing this : The unit price of product A is {{ unit_price }} EUR. Taking the standard discount into account, the sale price of 50 units is {{ price(unit_price, 50) }} EUR. If you defined a price() function, this could translate into: The unit price of product A is 10.00 EUR. Taking the standard discount into account, the sale price of 50 units is 450.00 EUR. It is possible to use the wide range of facilities provided by Jinja2 templates .","title":"Enrich markdown with templating"},{"location":"#create-your-own-macros-and-filters","text":"Instead of creating countless new plugins, programmers can define their macros and filters . Getting Started with Macros Need a function to display some repetitive markdown, or environment information? If you are a Python programmer, go ahead and create your own macros and filters in Python! It's actually much, much easier than writing a VBA function for Excel... Create a main.py file in the top directory of your mkdocs project and add this call: import ... def define_env(env): \"Hook function\" @env.macro def mymacro(...) ... return some_string You can insert a call in any markdown page of your project: {{ mymacro(...) }} Restart your mkdocs server. Et voil\u00e0 ! Producing HTML The result of a macro can also be HTML code : this makes macros especially useful to make custom extensions to the syntax of markdown, such as buttons, calls to email, embedding YouTube videos, etc.","title":"Create Your Own Macros and Filters"},{"location":"#boosting-large-or-complex-documentation-projects","text":"mkdocs-macros was also developed with large or complex projects in mind . You can include separate configurations files, import Jinja2 macro definitions, add \"post-production\" elements to your website, etc. You can go all the way as to pre-package modules into pluglets that can be installed as Python packages. Note By using mkdocs-macros, you can cut down the number of plugins required for your documentation project. In a wide range of cases, writing your own module with macros (Python functions for a single website), could save the effort of developing new plugins for mkdocs .","title":"Boosting large or complex documentation projects"},{"location":"#installation","text":"","title":"Installation"},{"location":"#prerequisites","text":"Python version > 3.5 MkDocs version >= 1.0 (it should work > 0.17 (it should be compatible with post 1.0 versions)","title":"Prerequisites"},{"location":"#standard-installation","text":"pip install mkdocs-macros-plugin If you wish to also run the tests or rebuild the project's documentation: pip install 'mkdocs-macros-plugin[test]'","title":"Standard installation"},{"location":"#manual-installation","text":"To install the package, download the code from its github page and run: python setup.py install","title":"\"Manual installation\""},{"location":"#declaration-of-the-macros-plugin","text":"Declare the plugin in the the file mkdocs.yml : plugins: - search - macros Warning If you are creating the plugins entry in your config file, you should also insert a line for the search plugin. In the absence of the plugins entry, MkDocs enables search by default. But when it is present, then you MUST declare it explicitly if you want to use it.","title":"Declaration of the macros plugin"},{"location":"#check-that-it-works","text":"Tip The recommended way to check that the plugin works properly is to add the following command in one of the pages of your site (let's say info.md ): {{ macros_info() }} In the terminal, restart the environment: > mkdocs serve You will notice that additional information now appears in the terminal: INFO - Building documentation... [macros] Macros arguments: {'module_name': 'main', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': ''} Within the browser (e.g. http://127.0.0.1:8000/info), you should see a description of the plugins environment: If you see it that information, you should be all set. Give a good look at the General List, since it gives you an overview of what you can do out of the box with the macros plugin. The other parts give you more detailed information.","title":"Check that it works"},{"location":"#configuration-of-the-plugin","text":"Here are all the possible arguments in the plugin section of the MkDocs' config file: Argument Default Description module_name main Name of the Python module containing macros, filters and variables. Indicate the file or directory, without extension; you may specify a path (e.g. include/module ). If no main module is available, it is ignored. modules [] List of preinstalled Python modules , i.e. listed by pip list . include_dir Directory for including external files include_yaml [] List of yaml files or key: filename pairs to be included j2_block_start_string Non-standard Jinja2 marker for start of block j2_block_end_string Non-standard Jinja2 marker for end of block j2_variable_start_string Non-standard Jinja2 marker for start of variable j2_variable_end_string Non-standard Jinja2 marker for end of variable For example: plugins: - search - macros: module_name: mymodule include_dir: include With reference to existing wiki engines such as Dokuwiki or Atlassian Confluence . \u21a9","title":"Configuration of the plugin"},{"location":"advanced/","text":"Advanced usage Introduction The purpose of this page is to provide information for large projects , or projects with specific technical requirements . Migrations to mkdocs-macros It may be useful for mkdocs projects which that have decided to adopt mkdocs-macros at some stage in their existence. Can I make mkdocs-macros build process to fail in case of error (instead of displaying the error on the page)? Yes. In a context of CD/CI (Continuous Development/Continuous Integration) the generation of the mkdocs site can be part of a larger script. In that case, the expected behavior is not to display the error message in the respective webpage (default behavior), but to terminate the build process with an error code. That is the best way to advertise that something went wrong. It should then be possible to consult the log (console output) and track down the offending markdown file and line number. To activate that behavior, set the on_error_fail parameter to true in the config file: plugins: - search - macros: # toggle to true if you are in CD/CI environment on_error_fail: true In that case, an error in a macro will terminate the mkdocs-macros build or serve process with an error 100 . Make the behavior depend on an environment variable As of version 1.2, mkdocs incorporates a yaml extension that allows the value of a configuration option to be set to the value of an environment variable. You could therefore write: plugins: - search - macros: on_error_fail: !ENV [MACRO_ERROR_FAIL, false] Meaning that the parameter \" on_error_fail should be set to the value of MACRO_ERROR_FAIL ; or if the environment variable is absent to false . How to prevent accidental interpretation of \"Jinja-like\" statements? Issue The most frequent issue, when adding the mkdocs-macros plugin to an existing mkdocs project, is some markdown pages may not be rendered correctly, or cause a syntax error, or some other error. The reason is that if Jinja2 template engine in the macro plugin meets any text that has the standard markers (typically starting with {% } or {{ ) this will cause a conflict: it will try to interpret that text as a macro and fail to behave properly. The most likely places where this can occur are the following: Location in Markdown file (Block or Inline) Description Code Documented Jinja2 statements (or similar syntax), LaTeX Maths LaTeX statements Elsewhere Some pre-existing templating or macro language, typically with some constructs starting with {# or {{ . Expected behaviors in case of failure If the statement does not fit Jinja2 syntax, a syntax error will be displayed in the rendered page. If mkdocs-macros mistakenly tries to interprets a syntactically valid Jinja2 statement containing a variable, the most likely result is that it will \"eat\" that statement : since it cannot make any sense of it, it will silently replace it with an empty string . If the statement looks like a macro (callable, with arguments), an error and traceback will be displayed in the page. Note This question of accidental rendering is covered generally in the Jinja2 documentation as escaping . Here we need to help mkdocs-macros clearly distinguish between two types of Jinja2 statements : Documentation statements , which must appear as-is in the final HTML pages, and therefore must not be interpreted by mkdocs-macros. Actionable Jinja2 statements : calls to variables or macros, etc., which mkdocs-macros must replace by their equivalent. Special Cases Code Blocks Containing Similar Languages With MkDocs, this situation typically occurs when the website is documenting an application that relies on a \" djangolike/jinjalike language \" like: Django Template Language Jinja2 (Python) Nunjucks (Javascript) Twig (PHP) ... This may also happen for pages that documents Ansible directives, which often contain variables expressed in a Jinja2 syntax . Snippets Containing LaTeX With the plug-in enabled, LaTeX snippets would fail to build because {{?}} will trigger the interpretation of a Jinja2 macro (since {{ and }} are markers).LaTeX snippets For example, the following LaTeX snippet is used to draw a table: ```LaTeX \\begin{tabular}{|ccc|} \\hline 2 & 9 & 4\\\\ 7 & \\multicolumn{2}{c|} {\\multirow{2}*{{?}}} \\\\ 6 & &\\\\ \\hline \\end{tabular} ``` Two Essential Notes Warning Fencing Jinja2 statements parts as blocks of code with the markdown convention (using three backticks or three tildes) will not prevent their interpretation, because this macros plugin intentionally ignores them. This is to allow advanced use cases where the content of the code block must be computed on the fly. No Risk of intereference of Jinja2 statements with HTML Rendering There is, of course, a third use of Jinja2 statements : MkDocs also use them in templates to render HTML pages. Fortunately, we can safely ignore that fact. There is in principle no risk that MkDocs will accidentally interpret any Jinja2 statements in markdown pages, during the HTML rendering process . The reason is that MkDocs contains a safety : it automatically escapes symbols such as '{' , which could have a meaning for the later rendering in HTML (which also uses Jinja2 templates). Here we are trying to solve a different problem: how to avoid interpretation of Jinja2 statements by mkdocs-macros , so that they actually appear in the HTML output ? Solutions Solution 1: Exclude a page from the rendering process From version 0.5.7 Tip This solution is a quick fix, if you are \"migrating\" a pre-existing mkdocs project under mkdocs-macros, and some markdown pages fail, or do not display correctly. This will leave more time to implement the next solutions. In the header of the markdown page, indicate that the markdown should be used \"as-is\" (no rendering of mkdocs-macros), by setting the ignore_macros meta-data key to the true value. --- # YAML header ignore_macros: true --- Any other value than true (or an absence of this key), will be interpreted as a false value. Solution 2: Snippets as jinja2 strings (one-liners) This hack works for simple one-line snippets. Suppose you want to prevent the string {{ 2 + 2 }} from being interpreted. It would be sufficient to treat it as if it was a string in jinja2. {{ \"{{ 2 + 2 }}\" }} You could also use expressions that contain the double quote symbol, but in this case you must bracket them with simple quotes: {{ '{{ \"Hello world\" }}' }} Warning Triple quotes ( \"\"\" ) around strings are not allowed in Jinja2, so this hack cannot be used for multiline statements. Solution 3: Explicitly marking the snippets as 'raw' The standard solution is to isolate each snippet of code that should not be interpreted, using the standard jinja2 raw directive, which exists for that purpose: {% raw %} - task: \"create a directory file: path: \"{{ folder_path }}\" state: directory recurse: true {% endraw %} Solution 4: Altering the syntax of jinja2 for mkdocs-macros Sometimes the introduction of mkdocs-macros comes late in the chain, and the existing pages already contain a lot of Jinja2 statements that are should appear in the final HTML pages: escaping all of them would not really be an option. Or else, you do not wish to bother the writers of markdown pages with the obligation of escaping Jinja2 statements. Solution Rather than refactoring all the existing markdown pages to fence those Jinja2 statements, it may be preferable to alter the markers for variables or blocks used in mkdocs-macros. For example, you may want to replace the curly brackets by square ones, like this: # This is a title It costs [[ unit_price ]]. [[% if unit_price > 5 %]] This is expensive! [[% endif %]] To obtain this result, simply add the following parameters in the macros section. There are two parameters for code blocks (start and end) and two for variables (start and end). - macros: j2_block_start_string: '[[%' j2_block_end_string: '%]]' j2_variable_start_string: '[[' j2_variable_end_string: ']]' You may, of course, chose the combination that best suits your needs. Caution 1: You are walking out of the beaten path. Altering the standard markers used in jinja2 has far-reaching consequences, because it will oblige you henceforth use a new form for templates, which is specific to your project. When reading this documentation, you will have to mentally convert all the examples. Caution 2: Use with discretion Errors in defining these new markers, or some accidental combinations of markers may have unpredictable consequences. Use with discretion, and at your own risk . In case of trouble, please do not expect help from the maintainers of this plugin. Including snippets in pages Usage To include snippets (markdown files) within a markdown file, you may use the include directive from jinja2, directly in your markdown code e.g.: ## Paragraph Including another markdown file will therefore execute the macros. By default the root directory for your included files is in docs_dir , Changing the directory of the includes You may change the directory of the includes, by setting the include_dir parameter in the plugin's configuration in the yaml file, e.g.: plugins: - search - macros: include_dir: include In this case, all files to be included will be found in the include subdirectory of your project's directory. These are the advantages for using a distinct directory for includes: The files to be included (\"partials\") will not be automatically rendered into html A better separation between normal pages and included pages If you often use mkdocs serve , modifying an included page will auto-reload the pages in the browser (the directory is added to the list of the \"watched\" directories). Other uses You could conceivably also include HTML files, since markdown may contain pure HTML code: The above would fetch the file from a in a html subdirectory (by default: docs/html ). Warning The external HTML file must not contain any <HTML> and <BODY> tags, as this will likely break the page. Also, you do not need to define any header, footer or navigation, or formatting instructions, as this is already taken care of by MkDocs. Tip To further enhance your website, you could use the include() macro to insert automatically generated files that contain regularly updated information (markdown or html), e.g.: last result of compilation / deployment, information contained in a database, etc. Importing macros from a separate file From version 0.5.10 On the other hand, it is possible to place your definitions in a single file, which you can import (see Jinja2 documentation ): {% import 'includes.md' as includes %} (in this case, all macros defined in the imported file will be available with a prefixed notation as, e.g. includes.myfunction ) You may also write: {% from 'includes.md' import myfunction %} By default the root directory for your included files is in docs_dir , in other words your docs directory. You can change this directory by setting include_dir parameter in the config file . Warning For versions < 0.5.10 Macros were imported as variables in the page context. It means what they were not available from imported definition files, which did not have access to this context (see explanation in Jinja2 documentation ). There workaround is to force Jinja2 to use the current page's context, e.g.: {% import 'includes.md' as includes with context%} {% from 'includes.md' import myfunction with context%} . Treating macros as variables? From version 0.5.10. The @env.macro decorator inserts macros into the env.macros dictionary. Macros thus defined will be part of the globals of the Jinja2 environment (see explanation in Jinja2 documentation . In principle you could also insert functions (or any other callable) into the env.variables dictionary, e.g.: def foo(...): ... return ... env.variables['foo'] = foo In this case, functions will also be available as Jinja2 macros, from the markdown pages. There is no particular reason, at this stage, to do this, but this information is given as clarificaiton, or in case it could find some application in the future. Difference with default method The difference is that macros defined in this way will be part of the context of each page (together with any other variables). They will not be available for {% import .. %} statements, unless you add the with context clause. You might also notice some (unsupported) side-effects when executing {{ macros_info() }} (those functions might not necessarily be listed where you would expect them). Including external yaml files Use case Tip If the size of your mkdocs.yml file getting too large because of variables? Why not splitting this file into separate files? When a documentation site is growing (number of pages and complexity), the number of variables in the extra: section of the yaml configuration file may start to increase fast. At this point the config file contains not only configuration data to help build the website (environment, repetitive snippets, etc.), but it has started including information that is pertinent to the subject of the documentation . The solution is to split the config file, by using external yaml files , which contain the domain-specific information. This creates a separation of concerns. It also reduces the number of modifications to the configuration file, and thus the risk that it becomes accidentally corrupted. Tip You may also want to generate some of these external yaml files automatically, e.g. from a database. Declaring external YAML files To include external data files, add the include_yaml to the configuration file of mkdocs ( mkdocs.yml by default), followed by the list of external filenames or key: filename pairs: plugins: - search - macros: include_yaml: - data/foo.yaml - data/bar.yaml - key: data/baz.yaml The default directory is the project's root. Upon loading, the plugin will read each yaml file in order and merge the variables with those read from the main configuration file. If an entry is specified in the key: filename format, the data from the file will be assigned to the key . In case of conflicts, the latest value will override the earlier ones. Merging branches The \"branches\" of the trees of dictionaries will be merged and, in case of conflict, the plugin will attempt to privilege the latest branch. Caution The purpose of this feature is only to allow a separation of concerns. For organizational purposes, you should separate your yaml files in a clean way, so that each yaml file covers a specific part of the tree. Otherwise, this might create complicated cases were the merging algorithm might not work as you expect. What you can and can't do with define_env() The fact is that you cannot actually access page information in the define_env() function, since it operates at the configuration stage of the page building process (during the on_config() event of MkDocs ). At that point, you don't have access to specific pages Vital Note on mkdocs-macros Of course, you can declare macros , which appear to act on pages. But realize that these are only declarations and that their execution is deferred . The macros will actually be run later (by MkDocs' on_page_markdown() event ), just before the markdown is rendered. The framework is so organized that, in macros, you are actually \"talking\" about objects that don't exist yet. So you cannot influence the rendering process other than by adding macros, variables and filters to mkdocs_macros . Do not modify system entities in env.variables Also, the system information in env.variables is for reading purposes. You could modify it in your Python code, of course (at your own peril). But by design , it may have no effect on the mechanics of mkdocs (these are shallow copies). Whatever you do in that way, is likely to be branded black magic . Directly influencing the markdown pages generated From version 0.5.2 There are specific cases where you want your module code to be able to modify the markdown code of a page, without using macros . The proper time to do that, would be before or after the macros (Jinja2 directives) have been processed. Technical note: a limitation of the macros mechanism The define_env() function operates at the time when MkDocs prepares the configuration of website (the on_config() event). This is a global event , i.e. any change made at this point will affect the whole website. The limitation is that the define_env() function is \"aware\" of the general configuration, not of the content of single pages. True , it allows you to declare macros which will be interpreted later, for each page (on the on_page() event). But it won't allow you to modify pages outside of that mechanism. Use Case 1: Adding meta values to a page There are cases where you want to make modifications to a specific markdown page, based on the content of that page. Typically, you may want to programmatically add some meta values to a page, to be forwarded to the HTML template. For example you'd want to be able to always have a value for this: <meta name=\"description\" content=\"{{ page.meta.description }}\" /> Warning Note that in the snippet above, Jinja2 is used by MkDocs to produce HTML pages. This is completely distinct from MkDocs-macros' use of Jinja2 on Markdown pages (it occurs at a later stage). Normally metadata would be defined in the YAML header of the markdown page : --- title: my title description: This is a description --- Issue But supposing this was not the case ? Or supposing you want to check or alter that information? Use Case 2: Modifying the raw_markdown generated for a page You might still change that raw markdown, if you really want, e.g. by adding \"footer\" information at the bottom of each page. Solution To act on such cases that vary with each markdown page (and depend on each page, not on the general configuration), you may use the two functions, before the markdown is actually rendered: on_pre_page_macros(env) : before the macros are interpreted (macros are still present). on_post_page_macros(env) : after the macros are rendered (macros have been interpreted). At that point, you have a string env.raw_markdown property available, which contains the markdown after the conversion of the Jinja2 template. For example: def on_post_page_macros(env): \"\"\" Actions to be done after macro interpretation, when the markdown is already generated \"\"\" # This information will get carried into the HTML template. env.page.meta['description'] = ... # This will add a (Markdown or HTML) footer footer = '\\n...' env.raw_markdown += footer Additional Notes for on_pre_page_macros() and on_post_page_macros() Time of execution They are executed by the on_page_markdown() event of MkDocs : before the rendering the page before or after interpretation of the macros, respectively They operates on a single page. Content and availability of env.page The page attribute of env , which contains much information specific to the page (title, filename, metadata, etc.), is available only from the point of on_pre_page_macros() on. It is not available for the define_env(env) function. It contains notably the following information: Attribute Value title title of the page abs_url the absolute url of the page from the top of the hierarchy canonical_url the complete url of the page (typically with https://... ) markdown the whole markdown code ( before interpretation; for the interpreted markdown , use instead env.raw_markdown , see below). meta the meta data dictionary, as updated (typically) from the YAML header. Accessing the raw markdown For the on_post_page_macros() event, the env object contains a raw_markdown attribute, which contains the markdown with the macros already interpreted. In case of need If the code of the macro modifies env.raw_markdown , the modifications will be reflected in the final HTML page. Use of Global variables To facilitate the communication between define_env() and on_page_markdown() you may want to define global variables within your module. For a refresher on this, see the summary on W3 Schools . Adding post-build files to the HTML website From version 0.5 Use case Sometimes, you want your Python code to add some files to the HTML website that MkDocs is producing, completely aside of MkDoc's usual production workflow. These could be: an extra HTML page an additional or updated image a RSS feed a form processor (written for example in the php language) .... Tip The logical idea is to add files to the site (HTML) directory, which is given by env.conf['site_dir'] . Beware the of the 'disappeared file' trap One problem will occur if you attempt to add files to the site directory from within the define_env() function in your macro module. The file will be created, but nevertheless it is going to \"disappear\". The reason is that the code of define_env() is executed during the on_config event of MkDocs; and you can expect the site directory to be wiped out later, during the build phase (which produces the HTML files) . So, of course, the files you just created will be deleted. Solution: Post-Build Actions The solution to do that, is to perform those additions as post-build actions (i.e. executed with on_post_build event). Here is an example. Suppose you want to add a special file (e.g. HTML). import os MY_FILENAME = 'foo.html' my_HTML = None def define_env(env): \"Definition of the module\" # put here your HTML content my_HTML = ...... def on_post_build(env): \"Post-build actions\" site_dir = env.conf['site_dir'] file_path = os.path.join(site_dir, MY_FILENAME) with open(file_path, 'w') as f: f.write(my_HTML) The mkdocs-macros plugin will pick up that function and execute it during as on on_post_build() action. Argument of on_post_build() In this case, the argument is env (as for define_env() ); it is not config as in the on_post_build() method in an MkDocs plugin. If you want to get the plugin's arguments, you can find them in the env.conf dictionary. Global variables To facilitate the communication between define_env() and on_post_build you may want to define global variables within your module (in this example: MY_FILENAME and my_HTML ). Warning Do not forget that any variable assigned for the first time within a function is by default a local variable: its content will be lost once the function is fully executed. In the example above, my_HTML must appear in the global definitions; which is why it was assigned an empty value.","title":"Advanced usage"},{"location":"advanced/#advanced-usage","text":"","title":"Advanced usage"},{"location":"advanced/#introduction","text":"The purpose of this page is to provide information for large projects , or projects with specific technical requirements . Migrations to mkdocs-macros It may be useful for mkdocs projects which that have decided to adopt mkdocs-macros at some stage in their existence.","title":"Introduction"},{"location":"advanced/#can-i-make-mkdocs-macros-build-process-to-fail-in-case-of-error-instead-of-displaying-the-error-on-the-page","text":"Yes. In a context of CD/CI (Continuous Development/Continuous Integration) the generation of the mkdocs site can be part of a larger script. In that case, the expected behavior is not to display the error message in the respective webpage (default behavior), but to terminate the build process with an error code. That is the best way to advertise that something went wrong. It should then be possible to consult the log (console output) and track down the offending markdown file and line number. To activate that behavior, set the on_error_fail parameter to true in the config file: plugins: - search - macros: # toggle to true if you are in CD/CI environment on_error_fail: true In that case, an error in a macro will terminate the mkdocs-macros build or serve process with an error 100 . Make the behavior depend on an environment variable As of version 1.2, mkdocs incorporates a yaml extension that allows the value of a configuration option to be set to the value of an environment variable. You could therefore write: plugins: - search - macros: on_error_fail: !ENV [MACRO_ERROR_FAIL, false] Meaning that the parameter \" on_error_fail should be set to the value of MACRO_ERROR_FAIL ; or if the environment variable is absent to false .","title":"Can I make mkdocs-macros build process to fail in case of error (instead of displaying the error on the page)?"},{"location":"advanced/#how-to-prevent-accidental-interpretation-of-jinja-like-statements","text":"","title":"How to prevent accidental interpretation of \"Jinja-like\" statements?"},{"location":"advanced/#issue","text":"The most frequent issue, when adding the mkdocs-macros plugin to an existing mkdocs project, is some markdown pages may not be rendered correctly, or cause a syntax error, or some other error. The reason is that if Jinja2 template engine in the macro plugin meets any text that has the standard markers (typically starting with {% } or {{ ) this will cause a conflict: it will try to interpret that text as a macro and fail to behave properly. The most likely places where this can occur are the following: Location in Markdown file (Block or Inline) Description Code Documented Jinja2 statements (or similar syntax), LaTeX Maths LaTeX statements Elsewhere Some pre-existing templating or macro language, typically with some constructs starting with {# or {{ . Expected behaviors in case of failure If the statement does not fit Jinja2 syntax, a syntax error will be displayed in the rendered page. If mkdocs-macros mistakenly tries to interprets a syntactically valid Jinja2 statement containing a variable, the most likely result is that it will \"eat\" that statement : since it cannot make any sense of it, it will silently replace it with an empty string . If the statement looks like a macro (callable, with arguments), an error and traceback will be displayed in the page. Note This question of accidental rendering is covered generally in the Jinja2 documentation as escaping . Here we need to help mkdocs-macros clearly distinguish between two types of Jinja2 statements : Documentation statements , which must appear as-is in the final HTML pages, and therefore must not be interpreted by mkdocs-macros. Actionable Jinja2 statements : calls to variables or macros, etc., which mkdocs-macros must replace by their equivalent.","title":"Issue"},{"location":"advanced/#special-cases","text":"","title":"Special Cases"},{"location":"advanced/#code-blocks-containing-similar-languages","text":"With MkDocs, this situation typically occurs when the website is documenting an application that relies on a \" djangolike/jinjalike language \" like: Django Template Language Jinja2 (Python) Nunjucks (Javascript) Twig (PHP) ... This may also happen for pages that documents Ansible directives, which often contain variables expressed in a Jinja2 syntax .","title":"Code Blocks Containing Similar Languages"},{"location":"advanced/#snippets-containing-latex","text":"With the plug-in enabled, LaTeX snippets would fail to build because {{?}} will trigger the interpretation of a Jinja2 macro (since {{ and }} are markers).LaTeX snippets For example, the following LaTeX snippet is used to draw a table: ```LaTeX \\begin{tabular}{|ccc|} \\hline 2 & 9 & 4\\\\ 7 & \\multicolumn{2}{c|} {\\multirow{2}*{{?}}} \\\\ 6 & &\\\\ \\hline \\end{tabular} ```","title":"Snippets Containing LaTeX"},{"location":"advanced/#two-essential-notes","text":"Warning Fencing Jinja2 statements parts as blocks of code with the markdown convention (using three backticks or three tildes) will not prevent their interpretation, because this macros plugin intentionally ignores them. This is to allow advanced use cases where the content of the code block must be computed on the fly. No Risk of intereference of Jinja2 statements with HTML Rendering There is, of course, a third use of Jinja2 statements : MkDocs also use them in templates to render HTML pages. Fortunately, we can safely ignore that fact. There is in principle no risk that MkDocs will accidentally interpret any Jinja2 statements in markdown pages, during the HTML rendering process . The reason is that MkDocs contains a safety : it automatically escapes symbols such as '{' , which could have a meaning for the later rendering in HTML (which also uses Jinja2 templates). Here we are trying to solve a different problem: how to avoid interpretation of Jinja2 statements by mkdocs-macros , so that they actually appear in the HTML output ?","title":"Two Essential Notes"},{"location":"advanced/#solutions","text":"","title":"Solutions"},{"location":"advanced/#solution-1-exclude-a-page-from-the-rendering-process","text":"From version 0.5.7 Tip This solution is a quick fix, if you are \"migrating\" a pre-existing mkdocs project under mkdocs-macros, and some markdown pages fail, or do not display correctly. This will leave more time to implement the next solutions. In the header of the markdown page, indicate that the markdown should be used \"as-is\" (no rendering of mkdocs-macros), by setting the ignore_macros meta-data key to the true value. --- # YAML header ignore_macros: true --- Any other value than true (or an absence of this key), will be interpreted as a false value.","title":"Solution 1: Exclude a page from the rendering process"},{"location":"advanced/#solution-2-snippets-as-jinja2-strings-one-liners","text":"This hack works for simple one-line snippets. Suppose you want to prevent the string {{ 2 + 2 }} from being interpreted. It would be sufficient to treat it as if it was a string in jinja2. {{ \"{{ 2 + 2 }}\" }} You could also use expressions that contain the double quote symbol, but in this case you must bracket them with simple quotes: {{ '{{ \"Hello world\" }}' }} Warning Triple quotes ( \"\"\" ) around strings are not allowed in Jinja2, so this hack cannot be used for multiline statements.","title":"Solution 2: Snippets as jinja2 strings (one-liners)"},{"location":"advanced/#solution-3-explicitly-marking-the-snippets-as-raw","text":"The standard solution is to isolate each snippet of code that should not be interpreted, using the standard jinja2 raw directive, which exists for that purpose: {% raw %} - task: \"create a directory file: path: \"{{ folder_path }}\" state: directory recurse: true {% endraw %}","title":"Solution 3: Explicitly marking the snippets as 'raw'"},{"location":"advanced/#solution-4-altering-the-syntax-of-jinja2-for-mkdocs-macros","text":"Sometimes the introduction of mkdocs-macros comes late in the chain, and the existing pages already contain a lot of Jinja2 statements that are should appear in the final HTML pages: escaping all of them would not really be an option. Or else, you do not wish to bother the writers of markdown pages with the obligation of escaping Jinja2 statements. Solution Rather than refactoring all the existing markdown pages to fence those Jinja2 statements, it may be preferable to alter the markers for variables or blocks used in mkdocs-macros. For example, you may want to replace the curly brackets by square ones, like this: # This is a title It costs [[ unit_price ]]. [[% if unit_price > 5 %]] This is expensive! [[% endif %]] To obtain this result, simply add the following parameters in the macros section. There are two parameters for code blocks (start and end) and two for variables (start and end). - macros: j2_block_start_string: '[[%' j2_block_end_string: '%]]' j2_variable_start_string: '[[' j2_variable_end_string: ']]' You may, of course, chose the combination that best suits your needs. Caution 1: You are walking out of the beaten path. Altering the standard markers used in jinja2 has far-reaching consequences, because it will oblige you henceforth use a new form for templates, which is specific to your project. When reading this documentation, you will have to mentally convert all the examples. Caution 2: Use with discretion Errors in defining these new markers, or some accidental combinations of markers may have unpredictable consequences. Use with discretion, and at your own risk . In case of trouble, please do not expect help from the maintainers of this plugin.","title":"Solution 4: Altering the syntax of jinja2 for mkdocs-macros"},{"location":"advanced/#including-snippets-in-pages","text":"","title":"Including snippets in pages"},{"location":"advanced/#usage","text":"To include snippets (markdown files) within a markdown file, you may use the include directive from jinja2, directly in your markdown code e.g.: ## Paragraph Including another markdown file will therefore execute the macros. By default the root directory for your included files is in docs_dir ,","title":"Usage"},{"location":"advanced/#changing-the-directory-of-the-includes","text":"You may change the directory of the includes, by setting the include_dir parameter in the plugin's configuration in the yaml file, e.g.: plugins: - search - macros: include_dir: include In this case, all files to be included will be found in the include subdirectory of your project's directory. These are the advantages for using a distinct directory for includes: The files to be included (\"partials\") will not be automatically rendered into html A better separation between normal pages and included pages If you often use mkdocs serve , modifying an included page will auto-reload the pages in the browser (the directory is added to the list of the \"watched\" directories).","title":"Changing the directory of the includes"},{"location":"advanced/#other-uses","text":"You could conceivably also include HTML files, since markdown may contain pure HTML code: The above would fetch the file from a in a html subdirectory (by default: docs/html ). Warning The external HTML file must not contain any <HTML> and <BODY> tags, as this will likely break the page. Also, you do not need to define any header, footer or navigation, or formatting instructions, as this is already taken care of by MkDocs. Tip To further enhance your website, you could use the include() macro to insert automatically generated files that contain regularly updated information (markdown or html), e.g.: last result of compilation / deployment, information contained in a database, etc.","title":"Other uses"},{"location":"advanced/#importing-macros-from-a-separate-file","text":"From version 0.5.10 On the other hand, it is possible to place your definitions in a single file, which you can import (see Jinja2 documentation ): {% import 'includes.md' as includes %} (in this case, all macros defined in the imported file will be available with a prefixed notation as, e.g. includes.myfunction ) You may also write: {% from 'includes.md' import myfunction %} By default the root directory for your included files is in docs_dir , in other words your docs directory. You can change this directory by setting include_dir parameter in the config file . Warning For versions < 0.5.10 Macros were imported as variables in the page context. It means what they were not available from imported definition files, which did not have access to this context (see explanation in Jinja2 documentation ). There workaround is to force Jinja2 to use the current page's context, e.g.: {% import 'includes.md' as includes with context%} {% from 'includes.md' import myfunction with context%} . Treating macros as variables? From version 0.5.10. The @env.macro decorator inserts macros into the env.macros dictionary. Macros thus defined will be part of the globals of the Jinja2 environment (see explanation in Jinja2 documentation . In principle you could also insert functions (or any other callable) into the env.variables dictionary, e.g.: def foo(...): ... return ... env.variables['foo'] = foo In this case, functions will also be available as Jinja2 macros, from the markdown pages. There is no particular reason, at this stage, to do this, but this information is given as clarificaiton, or in case it could find some application in the future. Difference with default method The difference is that macros defined in this way will be part of the context of each page (together with any other variables). They will not be available for {% import .. %} statements, unless you add the with context clause. You might also notice some (unsupported) side-effects when executing {{ macros_info() }} (those functions might not necessarily be listed where you would expect them).","title":"Importing macros from a separate file"},{"location":"advanced/#including-external-yaml-files","text":"","title":"Including external yaml files"},{"location":"advanced/#use-case","text":"Tip If the size of your mkdocs.yml file getting too large because of variables? Why not splitting this file into separate files? When a documentation site is growing (number of pages and complexity), the number of variables in the extra: section of the yaml configuration file may start to increase fast. At this point the config file contains not only configuration data to help build the website (environment, repetitive snippets, etc.), but it has started including information that is pertinent to the subject of the documentation . The solution is to split the config file, by using external yaml files , which contain the domain-specific information. This creates a separation of concerns. It also reduces the number of modifications to the configuration file, and thus the risk that it becomes accidentally corrupted. Tip You may also want to generate some of these external yaml files automatically, e.g. from a database.","title":"Use case"},{"location":"advanced/#declaring-external-yaml-files","text":"To include external data files, add the include_yaml to the configuration file of mkdocs ( mkdocs.yml by default), followed by the list of external filenames or key: filename pairs: plugins: - search - macros: include_yaml: - data/foo.yaml - data/bar.yaml - key: data/baz.yaml The default directory is the project's root. Upon loading, the plugin will read each yaml file in order and merge the variables with those read from the main configuration file. If an entry is specified in the key: filename format, the data from the file will be assigned to the key . In case of conflicts, the latest value will override the earlier ones.","title":"Declaring external YAML files"},{"location":"advanced/#merging-branches","text":"The \"branches\" of the trees of dictionaries will be merged and, in case of conflict, the plugin will attempt to privilege the latest branch. Caution The purpose of this feature is only to allow a separation of concerns. For organizational purposes, you should separate your yaml files in a clean way, so that each yaml file covers a specific part of the tree. Otherwise, this might create complicated cases were the merging algorithm might not work as you expect.","title":"Merging branches"},{"location":"advanced/#what-you-can-and-cant-do-with-define_env","text":"The fact is that you cannot actually access page information in the define_env() function, since it operates at the configuration stage of the page building process (during the on_config() event of MkDocs ). At that point, you don't have access to specific pages Vital Note on mkdocs-macros Of course, you can declare macros , which appear to act on pages. But realize that these are only declarations and that their execution is deferred . The macros will actually be run later (by MkDocs' on_page_markdown() event ), just before the markdown is rendered. The framework is so organized that, in macros, you are actually \"talking\" about objects that don't exist yet. So you cannot influence the rendering process other than by adding macros, variables and filters to mkdocs_macros . Do not modify system entities in env.variables Also, the system information in env.variables is for reading purposes. You could modify it in your Python code, of course (at your own peril). But by design , it may have no effect on the mechanics of mkdocs (these are shallow copies). Whatever you do in that way, is likely to be branded black magic .","title":"What you can and can't do with define_env()"},{"location":"advanced/#directly-influencing-the-markdown-pages-generated","text":"From version 0.5.2 There are specific cases where you want your module code to be able to modify the markdown code of a page, without using macros . The proper time to do that, would be before or after the macros (Jinja2 directives) have been processed. Technical note: a limitation of the macros mechanism The define_env() function operates at the time when MkDocs prepares the configuration of website (the on_config() event). This is a global event , i.e. any change made at this point will affect the whole website. The limitation is that the define_env() function is \"aware\" of the general configuration, not of the content of single pages. True , it allows you to declare macros which will be interpreted later, for each page (on the on_page() event). But it won't allow you to modify pages outside of that mechanism.","title":"Directly influencing the markdown pages generated"},{"location":"advanced/#use-case-1-adding-meta-values-to-a-page","text":"There are cases where you want to make modifications to a specific markdown page, based on the content of that page. Typically, you may want to programmatically add some meta values to a page, to be forwarded to the HTML template. For example you'd want to be able to always have a value for this: <meta name=\"description\" content=\"{{ page.meta.description }}\" /> Warning Note that in the snippet above, Jinja2 is used by MkDocs to produce HTML pages. This is completely distinct from MkDocs-macros' use of Jinja2 on Markdown pages (it occurs at a later stage). Normally metadata would be defined in the YAML header of the markdown page : --- title: my title description: This is a description --- Issue But supposing this was not the case ? Or supposing you want to check or alter that information?","title":"Use Case 1: Adding meta values to a page"},{"location":"advanced/#use-case-2-modifying-the-raw_markdown-generated-for-a-page","text":"You might still change that raw markdown, if you really want, e.g. by adding \"footer\" information at the bottom of each page.","title":"Use Case 2: Modifying the raw_markdown generated for a page"},{"location":"advanced/#solution","text":"To act on such cases that vary with each markdown page (and depend on each page, not on the general configuration), you may use the two functions, before the markdown is actually rendered: on_pre_page_macros(env) : before the macros are interpreted (macros are still present). on_post_page_macros(env) : after the macros are rendered (macros have been interpreted). At that point, you have a string env.raw_markdown property available, which contains the markdown after the conversion of the Jinja2 template. For example: def on_post_page_macros(env): \"\"\" Actions to be done after macro interpretation, when the markdown is already generated \"\"\" # This information will get carried into the HTML template. env.page.meta['description'] = ... # This will add a (Markdown or HTML) footer footer = '\\n...' env.raw_markdown += footer","title":"Solution"},{"location":"advanced/#additional-notes-for-on_pre_page_macros-and-on_post_page_macros","text":"","title":"Additional Notes for on_pre_page_macros() and on_post_page_macros()"},{"location":"advanced/#time-of-execution","text":"They are executed by the on_page_markdown() event of MkDocs : before the rendering the page before or after interpretation of the macros, respectively They operates on a single page.","title":"Time of execution"},{"location":"advanced/#content-and-availability-of-envpage","text":"The page attribute of env , which contains much information specific to the page (title, filename, metadata, etc.), is available only from the point of on_pre_page_macros() on. It is not available for the define_env(env) function. It contains notably the following information: Attribute Value title title of the page abs_url the absolute url of the page from the top of the hierarchy canonical_url the complete url of the page (typically with https://... ) markdown the whole markdown code ( before interpretation; for the interpreted markdown , use instead env.raw_markdown , see below). meta the meta data dictionary, as updated (typically) from the YAML header.","title":"Content and availability of env.page"},{"location":"advanced/#accessing-the-raw-markdown","text":"For the on_post_page_macros() event, the env object contains a raw_markdown attribute, which contains the markdown with the macros already interpreted. In case of need If the code of the macro modifies env.raw_markdown , the modifications will be reflected in the final HTML page.","title":"Accessing the raw markdown"},{"location":"advanced/#use-of-global-variables","text":"To facilitate the communication between define_env() and on_page_markdown() you may want to define global variables within your module. For a refresher on this, see the summary on W3 Schools .","title":"Use of Global variables"},{"location":"advanced/#adding-post-build-files-to-the-html-website","text":"From version 0.5","title":"Adding post-build files to the HTML website"},{"location":"advanced/#use-case_1","text":"Sometimes, you want your Python code to add some files to the HTML website that MkDocs is producing, completely aside of MkDoc's usual production workflow. These could be: an extra HTML page an additional or updated image a RSS feed a form processor (written for example in the php language) .... Tip The logical idea is to add files to the site (HTML) directory, which is given by env.conf['site_dir'] . Beware the of the 'disappeared file' trap One problem will occur if you attempt to add files to the site directory from within the define_env() function in your macro module. The file will be created, but nevertheless it is going to \"disappear\". The reason is that the code of define_env() is executed during the on_config event of MkDocs; and you can expect the site directory to be wiped out later, during the build phase (which produces the HTML files) . So, of course, the files you just created will be deleted.","title":"Use case"},{"location":"advanced/#solution-post-build-actions","text":"The solution to do that, is to perform those additions as post-build actions (i.e. executed with on_post_build event). Here is an example. Suppose you want to add a special file (e.g. HTML). import os MY_FILENAME = 'foo.html' my_HTML = None def define_env(env): \"Definition of the module\" # put here your HTML content my_HTML = ...... def on_post_build(env): \"Post-build actions\" site_dir = env.conf['site_dir'] file_path = os.path.join(site_dir, MY_FILENAME) with open(file_path, 'w') as f: f.write(my_HTML) The mkdocs-macros plugin will pick up that function and execute it during as on on_post_build() action. Argument of on_post_build() In this case, the argument is env (as for define_env() ); it is not config as in the on_post_build() method in an MkDocs plugin. If you want to get the plugin's arguments, you can find them in the env.conf dictionary. Global variables To facilitate the communication between define_env() and on_post_build you may want to define global variables within your module (in this example: MY_FILENAME and my_HTML ). Warning Do not forget that any variable assigned for the first time within a function is by default a local variable: its content will be lost once the function is fully executed. In the example above, my_HTML must appear in the global definitions; which is why it was assigned an empty value.","title":"Solution: Post-Build Actions"},{"location":"changelog/","text":"Changelog: mkdocs-macros All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 0.7.0, 2022-03-25 Added: (#133) on_error_fail in config file to make build/serve process fail in case of macro error, with return code 100. Added: (#130) Documentation on the tree structure of a typical macro directory (package) 0.6.4, 2022-01-27 Fixed: (#118) {{ git.date }} is now committer date (no longer author date). Added: new git info elements (author email, committer, committer email); documentation was updated Added: by default, unknown variables in a markdown page ( {{ foo }} ) are no longer replaced by blanks but displayed as is (DebugUndefined) (#117); for better compatibility with other plugins or error detection Added: on_undefined parameter in plugin definition to alter behavior with unknown jinja2 variables: 'keep' (default), 'silent', 'strict', 'lax'; documentation was updated 0.6.3, 2021-11-23 Fixed: Broken build of 0.6.2 0.6.2, 2021-11-22 (yanked) Added: env.raw_markdown is now modifiable, for use in on_post_page_macros() 0.6.1, 2021-09-09 Added: auto-install of pluglets (in module parameter in config file) 0.6.0, 2021-22-08 Fixed: documentation (for readthedocs) now contains proper link to edit uri on github Fixed: broken link in webdoc/docs/pages.md Bump version to 0.6.0, to acknowledge the breaking change in 0.5.10 0.5.12, 2021-06-09 Fixed: Incompatibility with mkdocs 1.2 ( on_serve() event, call to server.watch() ) 0.5.11, 2021-04-24 Added: Info on pluglets, on GitHub index page. Added: Contributing and Help pages, in documentation 0.5.10, 2021-04-23 Warning: Breaking Change Fixed: impossibility to use imported Jinja2 macros, without with context clause (#81). Now macros are imported as global. Removed: Do not define macros as variables any longer, but as macros. incorrect: env.variables['foo'] = foo (though it should still work) correct: prefix declaration with @env.macros or env.macros['foo'] = foo Added: Changelog is also part of documentation Added: Documentation moved under Material them, slate variant (dark) Added: Amended documentation (test install, discussions) 0.5.9, 2021-04-22 Added: Changelog (Fixed #82) 0.5.8, 2021-04-21 Fixed: display better message in case of macro syntax error (line_no, message, incriminated line in file). Traceback was useless with that specific exception, and has been removed. 0.5.7, 2021-04-21 Added: Possibility (for large projects) to exclude a markdown page from macro rendering, with ignore_macros: true in YAML header (fixed issue #78, and answered discussion #79) 0.5.6, 2021-04-19 Added: Files object to the mkdocs-macros environment (fixed #80) Fixed: Documentation errors or omissions Fixed: Do not install pluglet mkdocs-macros-test by default (#50) In order to do testing, type: pip install 'mkdocs-macros-plugin[test]' 0.5.5, 2021-03-03 Starting point","title":"Changelog"},{"location":"changelog/#changelog-mkdocs-macros","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog: mkdocs-macros"},{"location":"changelog/#070-2022-03-25","text":"Added: (#133) on_error_fail in config file to make build/serve process fail in case of macro error, with return code 100. Added: (#130) Documentation on the tree structure of a typical macro directory (package)","title":"0.7.0, 2022-03-25"},{"location":"changelog/#064-2022-01-27","text":"Fixed: (#118) {{ git.date }} is now committer date (no longer author date). Added: new git info elements (author email, committer, committer email); documentation was updated Added: by default, unknown variables in a markdown page ( {{ foo }} ) are no longer replaced by blanks but displayed as is (DebugUndefined) (#117); for better compatibility with other plugins or error detection Added: on_undefined parameter in plugin definition to alter behavior with unknown jinja2 variables: 'keep' (default), 'silent', 'strict', 'lax'; documentation was updated","title":"0.6.4, 2022-01-27"},{"location":"changelog/#063-2021-11-23","text":"Fixed: Broken build of 0.6.2","title":"0.6.3, 2021-11-23"},{"location":"changelog/#062-2021-11-22-yanked","text":"Added: env.raw_markdown is now modifiable, for use in on_post_page_macros()","title":"0.6.2, 2021-11-22 (yanked)"},{"location":"changelog/#061-2021-09-09","text":"Added: auto-install of pluglets (in module parameter in config file)","title":"0.6.1, 2021-09-09"},{"location":"changelog/#060-2021-22-08","text":"Fixed: documentation (for readthedocs) now contains proper link to edit uri on github Fixed: broken link in webdoc/docs/pages.md Bump version to 0.6.0, to acknowledge the breaking change in 0.5.10","title":"0.6.0, 2021-22-08"},{"location":"changelog/#0512-2021-06-09","text":"Fixed: Incompatibility with mkdocs 1.2 ( on_serve() event, call to server.watch() )","title":"0.5.12, 2021-06-09"},{"location":"changelog/#0511-2021-04-24","text":"Added: Info on pluglets, on GitHub index page. Added: Contributing and Help pages, in documentation","title":"0.5.11, 2021-04-24"},{"location":"changelog/#0510-2021-04-23","text":"Warning: Breaking Change Fixed: impossibility to use imported Jinja2 macros, without with context clause (#81). Now macros are imported as global. Removed: Do not define macros as variables any longer, but as macros. incorrect: env.variables['foo'] = foo (though it should still work) correct: prefix declaration with @env.macros or env.macros['foo'] = foo Added: Changelog is also part of documentation Added: Documentation moved under Material them, slate variant (dark) Added: Amended documentation (test install, discussions)","title":"0.5.10, 2021-04-23"},{"location":"changelog/#059-2021-04-22","text":"Added: Changelog (Fixed #82)","title":"0.5.9, 2021-04-22"},{"location":"changelog/#058-2021-04-21","text":"Fixed: display better message in case of macro syntax error (line_no, message, incriminated line in file). Traceback was useless with that specific exception, and has been removed.","title":"0.5.8, 2021-04-21"},{"location":"changelog/#057-2021-04-21","text":"Added: Possibility (for large projects) to exclude a markdown page from macro rendering, with ignore_macros: true in YAML header (fixed issue #78, and answered discussion #79)","title":"0.5.7, 2021-04-21"},{"location":"changelog/#056-2021-04-19","text":"Added: Files object to the mkdocs-macros environment (fixed #80) Fixed: Documentation errors or omissions Fixed: Do not install pluglet mkdocs-macros-test by default (#50) In order to do testing, type: pip install 'mkdocs-macros-plugin[test]'","title":"0.5.6, 2021-04-19"},{"location":"changelog/#055-2021-03-03","text":"Starting point","title":"0.5.5, 2021-03-03"},{"location":"contribute/","text":"Contributing to mkdocs-macros If you want to help, you've come to the right place. Adding an issue? If, after having consulted the existing issues , you want to add a new issue (for a bug or an enhancement request ), or comment on an existing one, you are welcome! All issues are carefully reviewed and often get a quick answer. Software issue, usage problem, not sure? There has been no need, so far, to regulate issues on this project. But if you don't know if what you are requesting is: a bug correction, a new feature, a hint on how to use mkdocs-macros, or you have an idea that is meaningful to you, and you wish to start a discussion , just use the project's Discussions space, on GitHub , and enter a new idea \ud83d\udca1. Your ideas \ud83d\udca1 are valuable: tell about them! Want to contribute code? Contributions of PRs (Pull Requests) are welcome! More information on how to make pull requests can be found on GitHub's docs . Important rule: Open an issue first! But there is a rule: Always open an issue first , and get a feedback. It's in everybody's interest to have a little discussion first: Perhaps the issue has already been fixed? There is a different way to do things? There is a pitfall to watch for? Perhaps your good idea could even be made better? \ud83d\ude42 If you submit a PR on github without referring to existing issue, you will likely be asked to open one, before anything else happens. If you have several PRs on the same issue, continue to refer to that issue. Want to correct or contribute documentation? Code is docs, and docs is code There is no substantial difference between code and documentation: Code is for machines. Documentation is for humans. Sometimes the division between the two is not even clear. Apply the same principles for documentation as for code .","title":"Contributing"},{"location":"contribute/#contributing-to-mkdocs-macros","text":"If you want to help, you've come to the right place.","title":"Contributing to mkdocs-macros"},{"location":"contribute/#adding-an-issue","text":"If, after having consulted the existing issues , you want to add a new issue (for a bug or an enhancement request ), or comment on an existing one, you are welcome! All issues are carefully reviewed and often get a quick answer.","title":"Adding an issue?"},{"location":"contribute/#software-issue-usage-problem-not-sure","text":"There has been no need, so far, to regulate issues on this project. But if you don't know if what you are requesting is: a bug correction, a new feature, a hint on how to use mkdocs-macros, or you have an idea that is meaningful to you, and you wish to start a discussion , just use the project's Discussions space, on GitHub , and enter a new idea \ud83d\udca1. Your ideas \ud83d\udca1 are valuable: tell about them!","title":"Software issue, usage problem, not sure?"},{"location":"contribute/#want-to-contribute-code","text":"Contributions of PRs (Pull Requests) are welcome! More information on how to make pull requests can be found on GitHub's docs . Important rule: Open an issue first! But there is a rule: Always open an issue first , and get a feedback. It's in everybody's interest to have a little discussion first: Perhaps the issue has already been fixed? There is a different way to do things? There is a pitfall to watch for? Perhaps your good idea could even be made better? \ud83d\ude42 If you submit a PR on github without referring to existing issue, you will likely be asked to open one, before anything else happens. If you have several PRs on the same issue, continue to refer to that issue.","title":"Want to contribute code?"},{"location":"contribute/#want-to-correct-or-contribute-documentation","text":"Code is docs, and docs is code There is no substantial difference between code and documentation: Code is for machines. Documentation is for humans. Sometimes the division between the two is not even clear. Apply the same principles for documentation as for code .","title":"Want to correct or contribute documentation?"},{"location":"git_info/","text":"Using Git Information Introduction A frequent requirement for the documentation of software projects, is to insert version information. Nowadays, the tool of choice for version control is git . Several specific plugins exist, this comes out of the box with mkdocs-macros. Plus, covers a wide range of use cases, from the simplest to more complicated ones. How to access Providing of course the site is under a git repository, information is provided out of the box in a page, through the git variable. To have the full string (corresponding to git log -1 on the command line): {{ git.raw }} To have, e.g. the short hash of the last commit, the date and the author: {{ git.short_commit}} ({{ git.date}}) by {{ git.author}} For the date, you may use the standard Python methods, e.g. strftime() : {{ git.date.strftime(\"%b %d, %Y %H:%M:%S\") }} Testing for the presence of git repo If the plugin cannot find the git executable, or if the page is not in a git repository, then git.status is set to False. If you want to print git information only if applicable: {% if git.status %} Git: {{ git.short_commit }} {% endif %} If the page is indeed in a git repo, but git.status is still False, try displaying {{ git.error }} Catalogue Here is a list of attributes of the git object: Attribute Description short_commit short hash of the last commit (e.g. 2bd7950 ) commit long hash of the last commit author author's name author_email author's email committer committer's name committer_email committer's email tag last active tag of the repo date full date of the commit (as a date object) date_ISO full date of the commit (as an ISO string) message full message of the last commit raw string description of the last commit root_dir root dir of the git repository status is git present? Note Most of the time, you might be interested in the author's information. For more information on the difference between author and committer, see the Pro Git Book, chapter 2.3 Tip To get the full list all attributes of the git object: {{ context(git)| pretty }} Date of the last commit In order to obtain a printout of the date of the last commit, you can use: {{ git.date }} which would return e.g.: 2020-05-13 16:08:52+02:00 Note For the commit dates ( date and date_ISO ) the common sense choice has been to use git's committer date , since that guarantees that if the commit has been modified (rebased, etc.), the date has been updated. Since it is a datetime object, you can also use any of the usual attributes ( .year , .month ), as well as the strftime() formatting method, e.g.: {{ git.date.strftime(\"%b %d, %Y %H:%M:%S\") }} which would return e.g. May 13, 2020 16:08:52 Tip: Is this really a git repo? In case you are not sure that there really is a git repo, you could use: {{ git.date or now() }} Which would give you at least the build date for the static website. Note that now() is also a datetime object.","title":"Git information"},{"location":"git_info/#using-git-information","text":"","title":"Using Git Information"},{"location":"git_info/#introduction","text":"A frequent requirement for the documentation of software projects, is to insert version information. Nowadays, the tool of choice for version control is git . Several specific plugins exist, this comes out of the box with mkdocs-macros. Plus, covers a wide range of use cases, from the simplest to more complicated ones.","title":"Introduction"},{"location":"git_info/#how-to-access","text":"Providing of course the site is under a git repository, information is provided out of the box in a page, through the git variable. To have the full string (corresponding to git log -1 on the command line): {{ git.raw }} To have, e.g. the short hash of the last commit, the date and the author: {{ git.short_commit}} ({{ git.date}}) by {{ git.author}} For the date, you may use the standard Python methods, e.g. strftime() : {{ git.date.strftime(\"%b %d, %Y %H:%M:%S\") }} Testing for the presence of git repo If the plugin cannot find the git executable, or if the page is not in a git repository, then git.status is set to False. If you want to print git information only if applicable: {% if git.status %} Git: {{ git.short_commit }} {% endif %} If the page is indeed in a git repo, but git.status is still False, try displaying {{ git.error }}","title":"How to access"},{"location":"git_info/#catalogue","text":"Here is a list of attributes of the git object: Attribute Description short_commit short hash of the last commit (e.g. 2bd7950 ) commit long hash of the last commit author author's name author_email author's email committer committer's name committer_email committer's email tag last active tag of the repo date full date of the commit (as a date object) date_ISO full date of the commit (as an ISO string) message full message of the last commit raw string description of the last commit root_dir root dir of the git repository status is git present? Note Most of the time, you might be interested in the author's information. For more information on the difference between author and committer, see the Pro Git Book, chapter 2.3 Tip To get the full list all attributes of the git object: {{ context(git)| pretty }}","title":"Catalogue"},{"location":"git_info/#date-of-the-last-commit","text":"In order to obtain a printout of the date of the last commit, you can use: {{ git.date }} which would return e.g.: 2020-05-13 16:08:52+02:00 Note For the commit dates ( date and date_ISO ) the common sense choice has been to use git's committer date , since that guarantees that if the commit has been modified (rebased, etc.), the date has been updated. Since it is a datetime object, you can also use any of the usual attributes ( .year , .month ), as well as the strftime() formatting method, e.g.: {{ git.date.strftime(\"%b %d, %Y %H:%M:%S\") }} which would return e.g. May 13, 2020 16:08:52","title":"Date of the last commit"},{"location":"git_info/#tip-is-this-really-a-git-repo","text":"In case you are not sure that there really is a git repo, you could use: {{ git.date or now() }} Which would give you at least the build date for the static website. Note that now() is also a datetime object.","title":"Tip: Is this really a git repo?"},{"location":"help/","text":"Where Can I get Help? RFM Read the Frigging on-line Manual and especially the Faq ... seriously: there are good chances that they already contain the answer you are looking for. \ud83d\ude42 Issues Check the issues on the GitHub repo. Tips Some issues have the marker Useful Tip . Also check the closed issues . It could be that your issue has already been solved and closed! Also, you could check similar issues, to see if they could point you to the answer. If all else fails... Check the Q&As \ud83d\ude4f (Questions & Answers) in the project's Discussions space, on GitHub . Post a Q&A \ud83d\ude4f item! If your question was answered... Please mark the question as Answered : this will be a precious indication for other users.","title":"Asking for help?"},{"location":"help/#where-can-i-get-help","text":"","title":"Where Can I get Help?"},{"location":"help/#rfm","text":"Read the Frigging on-line Manual and especially the Faq ... seriously: there are good chances that they already contain the answer you are looking for. \ud83d\ude42","title":"RFM"},{"location":"help/#issues","text":"Check the issues on the GitHub repo. Tips Some issues have the marker Useful Tip . Also check the closed issues . It could be that your issue has already been solved and closed! Also, you could check similar issues, to see if they could point you to the answer.","title":"Issues"},{"location":"help/#if-all-else-fails","text":"Check the Q&As \ud83d\ude4f (Questions & Answers) in the project's Discussions space, on GitHub . Post a Q&A \ud83d\ude4f item! If your question was answered... Please mark the question as Answered : this will be a precious indication for other users.","title":"If all else fails..."},{"location":"license/","text":"MIT License Copyright (C) 2018-20 Laurent Franceschetti Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#mit-license","text":"Copyright (C) 2018-20 Laurent Franceschetti Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"macros/","text":"Writing modules Introduction Modules are libraries of macros, filters and variables, which can be used by your MkDocs project. Every module MUST contain a define_env() function , which contains the declarations. Location of the modules Local module By default, the Python code must go into one main.py file in the main website's project directory (generally beside the mkdocs.yml file). If no main module is available, this is ignored. If you wish, you can change the name of that module by adding a module_name entry to the mkdocs.yml file (no need to add the .py suffix): plugins: ... - macros: module_name: source_code If you specify a module name, it must be available, or this will raise an error. Note If you wish, you can implement your module as a package (subdirectory) instead of a single file. Preinstalled modules (pluglets) If you wish to re-use modules across several documentation projects, you may want to pre-install them, turning them into pluglets . The define_env() function Note New, as of version 0.3.0 As a first step, you need declare a hook function called define_env , with one argument: env (object). This object contains the environment (variables, filters, etc.) of the templating tool (Jinja2). This is the information that will be used to generate the pure Markdown pages, which will then be translated into HTML (and displayed in a browser). Registration of variables, macros and filters The example should be self-explanatory: \"\"\" Basic example of a Mkdocs-macros module \"\"\" import math def define_env(env): \"\"\" This is the hook for defining variables, macros and filters - variables: the dictionary that contains the environment variables - macro: a decorator function, to declare a macro. - filter: a function with one of more arguments, used to perform a transformation \"\"\" # add to the dictionary of variables available to markdown pages: env.variables['baz'] = \"John Doe\" # NOTE: you may also treat env.variables as a namespace, # with the dot notation: env.variables.baz = \"John Doe\" @env.macro def bar(x): return (2.3 * x) + 7 # If you wish, you can declare a macro with a different name: def f(x): return x * x env.macro(f, 'barbaz') # or to export some predefined function env.macro(math.floor) # will be exported as 'floor' # create a jinja2 filter @env.filter def reverse(x): \"Reverse a string (and uppercase)\" return x.upper()[::-1] No special imports are required besides those you would need to write your functions (the env object does all the 'magic'). Tip You can export (as variables, macros or filters) a wide range of objects, and their attributes will remain accessible to the jinja2 template via the standard Python convention, e.g. {{ foo.bar }} (see more information ) Definition of variables/macros/filters You register a variable for MkDocs-macros by adding a key/value pair to the env.variables dictionary (or namespace). Variables are loaded with each page being rendered. You register a macro by decorating a function with the expression @env.macro (or by adding it to the env.macros dictionary). Macros are loaded in the global namespace of the Jinja2 environment. 1 . You register a filter by decorating a function with the expression @env.filter (or by adding it to the env.filters dictionary). This must be done within that define_env() function. You may, however, place any imports or other declarations outside of the function. Priority of variables Warning In case of conflict, variables declared in the Python module will override those created by users in YAML files ( extra ). This is a safety feature, to ensure that the maintainers of that file will not accidentally break the setup defined by programmers in the module. Conversely, keep that fact in mind, if users start complaining that an extra value has a different value than the one which they expected! Content of the env object Description The env object is used for introspection , i.e. is to get information on the project or page. Here is a list of commonly needed attributes (constants) or functions of that object: Item Type Description variables attribute The namespace that contains the variables and macros that will be available in mardkown pages with {{ ... }} notation. This dictionary is initialized with the values contained in the extra section of the configuration file (and optionally, with external yaml files). This object is also accessible with the dot notation; e.g. env.variables['foo'] is equivalent to env.variables.foo . macro function A decorator function that you can use to declare a Python function as a Jinja2 callable ('macro' for MkDocs). filters attribute A list list of jinja2 filters (default None) filter function A decorator for declaring a Python function as a jinja2 custom filter project_dir attribute The source directory of the MkDocs project (useful for finding or including other files) conf attribute The content of the config file ( mkdocs.yaml ). config attribute This can be a useful object; it contains the global context for MkDocs] 2 . page attribute The information on the page being served (such as the title, etc.). For more information on its content, see MkDoc's description of the page object . Technical Note env is essentially an instance of a subclass of the MkDocs' BasePlugin class , with some additional properties. Whatever you find in the BasePlugin class, you will find in the the env object. Accessing the whole config file ( mkdocs.yaml ) Sometimes, you might need information from the whole config file ( mkdocs.yaml ) , e.g. site_description , theme , copyright , etc. The property conf of the env object contains that information. For example you could define such a function: @env.macro def site_info(): \"Return general info on the website (name, description and theme)\" info = (env.conf['site_name'], env.conf['site_description'], env.conf['theme'].name) return \"%s/%s (theme: %s)\" % info Beware the change of name Beware that the what is usually called config is alled env.conf in the module. That is is because there is already env.config property as part of the BasePlugin class. Indeed, you will also find the same object under env.variables.config ; in other words, it will be thus be accessible as {{ config }} within the markdown pages. Tip In order obtain the documents directory ( docs ), you can use, within the Python module, the value: env.conf['docs_dir'] . Manipulating the MkDocs configuration information env.config is the object containing the global context for mkdocs, i.e. the data structures that are being manipulated to create the final HTML web site. You would have to explore it (using the MkDocs documentation on the global context ), but it contains the navigation ( env.conf['nav'] ), as well as all objects that could be manipulated. Note env.config is thus a superset of the env.conf object (which is env.config['config'] ). Caution This object is not accessible as a variable from the markdown pages. Exposing it might encourage black magic. Validating environment variables in Python code By design, the call to define_env() is the last stage of the config process, to create the jinja2 environment that will interpret the jinja2 directives inserted in the markdown code. It means in particular, that you can test the variables dictionary to validate its key/values, and to take appropriate action. For example, to check that root branches are present in the variables tree: MINIMAL_BRANCHES = ('foo', 'bar', 'baz') def define_env(env): \"\"\" This is the hook for defining variables, macros and filters ... \"\"\" # initial checks for branch in MINIMAL_BRANCHES: if branch not in env.variables: raise KeyError(\"Branch '%s' is not in environment variables! \") Tip This is a place where you could check that you code will not conflict with variables defined in the configuration files. You may also verify other aspects of the configuration file ( env.conf ). Note that the attributes of the pluging->macro branch are automatically checked by mkdocs (type and default value). List of hook functions within a module define_env() is not the only possible hook within a module. There are other functions available. Each is triggered by a MkDocs event . Function Description Typical Use Triggered by MkDoc's event define_env(env) Main function Create macros, filters, etc. on_config on_pre_page_macros(env) Executed just before the Jinja2 directives (markdown page) have been rendered Directly modify a markdown page on_page on_post_page_macros(env) Executed just after the Jinja2 code (markdown page) have been rendered Directly modify a markdown page on_page on_post_build(env) Executed after the html pages have been produced Add files to the website on_post_build declare_variables(variables, macro) Main function Deprecated (< version 0.3.0) on_config Implementing the module as a package (module subdirectory) Instead of implementing the Python module as a file (typically main.py ), you can create a package (i.e. a main subdirectory). The Python rules for defining a package apply: particularly the dot ( . ) prefix for relative imports inside the package. The define_env() function should be accessible through the __init__.py file. A typical directory file could look like this: main \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 util.py \u251c\u2500\u2500 ... \u2514\u2500\u2500 ... The __init__.py file could look like this: from .util import foo, bar def define_env(env): \"\"\" This is the hook for defining variables, macros and filters \"\"\" @env.macro def make_foo(): ....... return foo(s) @env.macro def get_bar(s): s = bar(s, ...) return s ... A caution about security Warning It is true that you are generating static pages. Nevertheless, think about potential side effects of macros (in case of error or abuse) or about the risks of exposing sensitive information, if the writers of markdown pages are different persons than the maintainers of the webserver . Depending on your use case, you may want to give access to the shell (e.g. for a development team). Or else, may you want to \"sandbox\" your web pages (for business applications). The declare_variables() function (DEPRECATED) Warning declare_variables() is the old paradigm, before 0.3.0 and it is DEPRECATED. Support for this call will be discontinued in a future version. Use instead the define_env() function. As a first step, you need declare a hook function called declare_variables , with two arguments: variables : the dictionary that contains the variables. It is initialized with the values contained in the extra section of the mkdocs.yml file. macro : a decorator function that you can use to declare a Python function as a Jinja2 callable ('macro' for MkDocs). The example should be self-explanatory: def declare_variables(variables, macro): \"\"\" This is the hook for the functions - variables: the dictionary that contains the environment variables - macro: a decorator function, to declare a macro. \"\"\" variables['baz'] = \"John Doe\" @macro def bar(x): return (2.3 * x) + 7 # If you wish, you can declare a macro with a different name: def f(x): return x * x macro(f, 'barbaz') # or to export some predefined function import math macro(math.floor) # will be exported as 'floor' Your registration of variables or macros for MkDocs should be done inside that hook function. On the other hand, nothing prevents you from making imports or declarations outside of this function. Note: You can export a wide range of objects, and their attributes remain accessible (see more information ) Accessing variables In case you need to access some variables defined in the config file (under extra ), use the variables dictionary: Suppose you have: extra: price: 12.50 You could write a macro: @macro def compare_price(my_price): \"Compare the price to the price in config file\" if my_price > env.variables['price']: return(\"Price is higher than standard\") else: return(\"Price is lower than standard\") For your convenience, you may also use the dot notation: @macro def compare_price(my_price): \"Compare the price to the price in config file\" if my_price > env.variables.price: return(\"Price is higher than standard\") else: return(\"Price is lower than standard\") Accessing macros A macro is Python variable Note that since a macro is also a Python variable (function), you can also \"import\" it in a module. For example, fix_url is a predefined macro that fixes relative urls (when applicable) so that they point to the root of the site: fix_url = env.macros.fix_url my_url = fix_url(url) From version 0.5.10. Before that, macros were inserted in env.variables . \u21a9 env.config versus env.conf : it is unhappy that env.config represents MkDocs whole context, whereas env.conf represents only the config (YAML) file (a subset). This ambiguity was born from the fact that MkDoc itself used config to represent the context, as a property of the BasePlugin object. \u21a9","title":"Writing modules"},{"location":"macros/#writing-modules","text":"","title":"Writing modules"},{"location":"macros/#introduction","text":"Modules are libraries of macros, filters and variables, which can be used by your MkDocs project. Every module MUST contain a define_env() function , which contains the declarations.","title":"Introduction"},{"location":"macros/#location-of-the-modules","text":"","title":"Location of the modules"},{"location":"macros/#local-module","text":"By default, the Python code must go into one main.py file in the main website's project directory (generally beside the mkdocs.yml file). If no main module is available, this is ignored. If you wish, you can change the name of that module by adding a module_name entry to the mkdocs.yml file (no need to add the .py suffix): plugins: ... - macros: module_name: source_code If you specify a module name, it must be available, or this will raise an error. Note If you wish, you can implement your module as a package (subdirectory) instead of a single file.","title":"Local module"},{"location":"macros/#preinstalled-modules-pluglets","text":"If you wish to re-use modules across several documentation projects, you may want to pre-install them, turning them into pluglets .","title":"Preinstalled modules (pluglets)"},{"location":"macros/#the-define_env-function","text":"Note New, as of version 0.3.0 As a first step, you need declare a hook function called define_env , with one argument: env (object). This object contains the environment (variables, filters, etc.) of the templating tool (Jinja2). This is the information that will be used to generate the pure Markdown pages, which will then be translated into HTML (and displayed in a browser).","title":"The define_env() function"},{"location":"macros/#registration-of-variables-macros-and-filters","text":"The example should be self-explanatory: \"\"\" Basic example of a Mkdocs-macros module \"\"\" import math def define_env(env): \"\"\" This is the hook for defining variables, macros and filters - variables: the dictionary that contains the environment variables - macro: a decorator function, to declare a macro. - filter: a function with one of more arguments, used to perform a transformation \"\"\" # add to the dictionary of variables available to markdown pages: env.variables['baz'] = \"John Doe\" # NOTE: you may also treat env.variables as a namespace, # with the dot notation: env.variables.baz = \"John Doe\" @env.macro def bar(x): return (2.3 * x) + 7 # If you wish, you can declare a macro with a different name: def f(x): return x * x env.macro(f, 'barbaz') # or to export some predefined function env.macro(math.floor) # will be exported as 'floor' # create a jinja2 filter @env.filter def reverse(x): \"Reverse a string (and uppercase)\" return x.upper()[::-1] No special imports are required besides those you would need to write your functions (the env object does all the 'magic'). Tip You can export (as variables, macros or filters) a wide range of objects, and their attributes will remain accessible to the jinja2 template via the standard Python convention, e.g. {{ foo.bar }} (see more information )","title":"Registration of variables, macros and filters"},{"location":"macros/#definition-of-variablesmacrosfilters","text":"You register a variable for MkDocs-macros by adding a key/value pair to the env.variables dictionary (or namespace). Variables are loaded with each page being rendered. You register a macro by decorating a function with the expression @env.macro (or by adding it to the env.macros dictionary). Macros are loaded in the global namespace of the Jinja2 environment. 1 . You register a filter by decorating a function with the expression @env.filter (or by adding it to the env.filters dictionary). This must be done within that define_env() function. You may, however, place any imports or other declarations outside of the function.","title":"Definition of variables/macros/filters"},{"location":"macros/#priority-of-variables","text":"Warning In case of conflict, variables declared in the Python module will override those created by users in YAML files ( extra ). This is a safety feature, to ensure that the maintainers of that file will not accidentally break the setup defined by programmers in the module. Conversely, keep that fact in mind, if users start complaining that an extra value has a different value than the one which they expected!","title":"Priority of variables"},{"location":"macros/#content-of-the-env-object","text":"","title":"Content of the env object"},{"location":"macros/#description","text":"The env object is used for introspection , i.e. is to get information on the project or page. Here is a list of commonly needed attributes (constants) or functions of that object: Item Type Description variables attribute The namespace that contains the variables and macros that will be available in mardkown pages with {{ ... }} notation. This dictionary is initialized with the values contained in the extra section of the configuration file (and optionally, with external yaml files). This object is also accessible with the dot notation; e.g. env.variables['foo'] is equivalent to env.variables.foo . macro function A decorator function that you can use to declare a Python function as a Jinja2 callable ('macro' for MkDocs). filters attribute A list list of jinja2 filters (default None) filter function A decorator for declaring a Python function as a jinja2 custom filter project_dir attribute The source directory of the MkDocs project (useful for finding or including other files) conf attribute The content of the config file ( mkdocs.yaml ). config attribute This can be a useful object; it contains the global context for MkDocs] 2 . page attribute The information on the page being served (such as the title, etc.). For more information on its content, see MkDoc's description of the page object . Technical Note env is essentially an instance of a subclass of the MkDocs' BasePlugin class , with some additional properties. Whatever you find in the BasePlugin class, you will find in the the env object.","title":"Description"},{"location":"macros/#accessing-the-whole-config-file-mkdocsyaml","text":"Sometimes, you might need information from the whole config file ( mkdocs.yaml ) , e.g. site_description , theme , copyright , etc. The property conf of the env object contains that information. For example you could define such a function: @env.macro def site_info(): \"Return general info on the website (name, description and theme)\" info = (env.conf['site_name'], env.conf['site_description'], env.conf['theme'].name) return \"%s/%s (theme: %s)\" % info Beware the change of name Beware that the what is usually called config is alled env.conf in the module. That is is because there is already env.config property as part of the BasePlugin class. Indeed, you will also find the same object under env.variables.config ; in other words, it will be thus be accessible as {{ config }} within the markdown pages. Tip In order obtain the documents directory ( docs ), you can use, within the Python module, the value: env.conf['docs_dir'] .","title":"Accessing the whole config file (mkdocs.yaml)"},{"location":"macros/#manipulating-the-mkdocs-configuration-information","text":"env.config is the object containing the global context for mkdocs, i.e. the data structures that are being manipulated to create the final HTML web site. You would have to explore it (using the MkDocs documentation on the global context ), but it contains the navigation ( env.conf['nav'] ), as well as all objects that could be manipulated. Note env.config is thus a superset of the env.conf object (which is env.config['config'] ). Caution This object is not accessible as a variable from the markdown pages. Exposing it might encourage black magic.","title":"Manipulating the MkDocs configuration information"},{"location":"macros/#validating-environment-variables-in-python-code","text":"By design, the call to define_env() is the last stage of the config process, to create the jinja2 environment that will interpret the jinja2 directives inserted in the markdown code. It means in particular, that you can test the variables dictionary to validate its key/values, and to take appropriate action. For example, to check that root branches are present in the variables tree: MINIMAL_BRANCHES = ('foo', 'bar', 'baz') def define_env(env): \"\"\" This is the hook for defining variables, macros and filters ... \"\"\" # initial checks for branch in MINIMAL_BRANCHES: if branch not in env.variables: raise KeyError(\"Branch '%s' is not in environment variables! \") Tip This is a place where you could check that you code will not conflict with variables defined in the configuration files. You may also verify other aspects of the configuration file ( env.conf ). Note that the attributes of the pluging->macro branch are automatically checked by mkdocs (type and default value).","title":"Validating environment variables in Python code"},{"location":"macros/#list-of-hook-functions-within-a-module","text":"define_env() is not the only possible hook within a module. There are other functions available. Each is triggered by a MkDocs event . Function Description Typical Use Triggered by MkDoc's event define_env(env) Main function Create macros, filters, etc. on_config on_pre_page_macros(env) Executed just before the Jinja2 directives (markdown page) have been rendered Directly modify a markdown page on_page on_post_page_macros(env) Executed just after the Jinja2 code (markdown page) have been rendered Directly modify a markdown page on_page on_post_build(env) Executed after the html pages have been produced Add files to the website on_post_build declare_variables(variables, macro) Main function Deprecated (< version 0.3.0) on_config","title":"List of hook functions within a module"},{"location":"macros/#implementing-the-module-as-a-package-module-subdirectory","text":"Instead of implementing the Python module as a file (typically main.py ), you can create a package (i.e. a main subdirectory). The Python rules for defining a package apply: particularly the dot ( . ) prefix for relative imports inside the package. The define_env() function should be accessible through the __init__.py file. A typical directory file could look like this: main \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 util.py \u251c\u2500\u2500 ... \u2514\u2500\u2500 ... The __init__.py file could look like this: from .util import foo, bar def define_env(env): \"\"\" This is the hook for defining variables, macros and filters \"\"\" @env.macro def make_foo(): ....... return foo(s) @env.macro def get_bar(s): s = bar(s, ...) return s ...","title":"Implementing the module as a package (module subdirectory)"},{"location":"macros/#a-caution-about-security","text":"Warning It is true that you are generating static pages. Nevertheless, think about potential side effects of macros (in case of error or abuse) or about the risks of exposing sensitive information, if the writers of markdown pages are different persons than the maintainers of the webserver . Depending on your use case, you may want to give access to the shell (e.g. for a development team). Or else, may you want to \"sandbox\" your web pages (for business applications).","title":"A caution about security"},{"location":"macros/#the-declare_variables-function-deprecated","text":"Warning declare_variables() is the old paradigm, before 0.3.0 and it is DEPRECATED. Support for this call will be discontinued in a future version. Use instead the define_env() function. As a first step, you need declare a hook function called declare_variables , with two arguments: variables : the dictionary that contains the variables. It is initialized with the values contained in the extra section of the mkdocs.yml file. macro : a decorator function that you can use to declare a Python function as a Jinja2 callable ('macro' for MkDocs). The example should be self-explanatory: def declare_variables(variables, macro): \"\"\" This is the hook for the functions - variables: the dictionary that contains the environment variables - macro: a decorator function, to declare a macro. \"\"\" variables['baz'] = \"John Doe\" @macro def bar(x): return (2.3 * x) + 7 # If you wish, you can declare a macro with a different name: def f(x): return x * x macro(f, 'barbaz') # or to export some predefined function import math macro(math.floor) # will be exported as 'floor' Your registration of variables or macros for MkDocs should be done inside that hook function. On the other hand, nothing prevents you from making imports or declarations outside of this function. Note: You can export a wide range of objects, and their attributes remain accessible (see more information )","title":"The declare_variables() function (DEPRECATED)"},{"location":"macros/#accessing-variables","text":"In case you need to access some variables defined in the config file (under extra ), use the variables dictionary: Suppose you have: extra: price: 12.50 You could write a macro: @macro def compare_price(my_price): \"Compare the price to the price in config file\" if my_price > env.variables['price']: return(\"Price is higher than standard\") else: return(\"Price is lower than standard\") For your convenience, you may also use the dot notation: @macro def compare_price(my_price): \"Compare the price to the price in config file\" if my_price > env.variables.price: return(\"Price is higher than standard\") else: return(\"Price is lower than standard\")","title":"Accessing variables"},{"location":"macros/#accessing-macros","text":"A macro is Python variable Note that since a macro is also a Python variable (function), you can also \"import\" it in a module. For example, fix_url is a predefined macro that fixes relative urls (when applicable) so that they point to the root of the site: fix_url = env.macros.fix_url my_url = fix_url(url) From version 0.5.10. Before that, macros were inserted in env.variables . \u21a9 env.config versus env.conf : it is unhappy that env.config represents MkDocs whole context, whereas env.conf represents only the config (YAML) file (a subset). This ambiguity was born from the fact that MkDoc itself used config to represent the context, as a property of the BasePlugin object. \u21a9","title":"Accessing macros"},{"location":"pages/","text":"How to Write \"Enriched\" Markdown Pages Definitions 1. Variable A variable is a predefined value. The primary source of variables is the extra namespace in the config file (by default: mkdocs.yml ). You can add variables in the Python module. Also local variables can be added directly to each markdown page, thanks to jinja2 directives, called set (those local variables are accessible by jinja2 directives, but not the Python code). 2. Macro We call macros , Python functions (or callables) that will be used in jinja2 snippets within the markdown pages. A macro should return a string that can be plain, markdown or HTML. Each call to the macro in markdown page will be replaced by that result. Note For more information on the full concept of a macro, see the detailed explanation . 3. Filter A custom filter is a Jinja2 concept. It is essentially a Python function used with a different syntax, e.g. {{ 'my text ' | uppercase}} (supposing there was a custom function called uppercase and declared as a filter). Just as a macro, a filter should return a string that can be plain, markdown or HTML. \"Batteries included\": defaut objects The following objects are, in particular, available by default, with their set of attributes: Object Description config The standard config information on MkDocs' environment. page Info on the current page ( source ) navigation List of all pages/sections of the website; sections are themselves list of pages; ( source ) environment Data on the system on which MkDocs is currently running. plugin Arguments of the macro plugin, in the config file git Information on the git version of the website (if part of a git repository) files The file structure (for advanced users who know how to manipulate the mkdocs.structure.files.Files object, as well as mkdocs.structure.files.File objects) For example, {{ config.site_name }} returns the main title of the website {{ environment.system }} returns the name of the OS. {{ navigation.pages }} returns a flattened list of all pages {{ plugin.module }} name of the Python module To discover what each of these objects contain, you can use the pretty filter provided with the plugin, e.g.: {{ context(page) | pretty }} Configuration variables To easily and quickly define custom variables, declare them in you mkdocs.yml file: extra: price: 12.50 company: name: Acme address: .... website: www.acme.com In your markdown file: The price of the product is {{ price }}. See [more information on the website]({{ company.website }}). See <a href=\"{{ company.website }}\">more information on the website</a>. Local (page-level) variables and macros If you really need a variable or macro that needs to remain local to the markdown page, you can use a standard Jinja2 declaration. Warning Note that the context() macro (for listing variables) will not display variables defined at page level. In the YAML header of the page Variables defined in the YAML header of the page are accessible as themselves and via the page.meta object. For example, if the the header is as follows: --- title: My special title bottles: whine: 500 beer: 123 --- Then you can access the content of the YAML header in two ways: By name e.g. {{ title }} and {{ bottles.whine }} Explicitly, i.e. using the dot notation, e.g. {{ page.meta.title }} and {{ page.meta.bottles.whine }} . Tip {{ page.meta }} gives the content of the header. If you wish to have it typed in a nice tabular form, you can use: {{ context(page.meta) | pretty }} Caution If variables in the metadata have the same name as variables already defined (suche as extra , config , etc.) those will be overwritten, but for this page only. Using the set keyword Variables can be defined in the template with the set keyword, e.g.: {% set acme = 'Acme Company Ltd' %} Please buy the great products from {{ acme }}! Contrary to variables defined in the extra section of the mkdocs.yml file, they are accessible only within the specific page. They are not accessible from the python code. Tip If you need reference information on the page, there is a page object e.g.: {{ page.title }} , {{ page.url }} , {{ page.is_homepage }} , etc. Page-level macros It is possible to write Jinja2 macros written with the Jinja2 syntax (instead of a Python module). This allows you benefit from the power of that language for the manipulation of strings. Here is an example of Jinja2 macro, from the official documentation: {% macro input(name, value='', type='text', size=20) -%} <input type=\"{{ type }}\" name=\"{{ name }}\" value=\"{{ value|e }}\" size=\"{{ size }}\"> {%- endmacro %} Which can be called (within the page) as: <p>{{ input('username') }}</p> <p>{{ input('password', type='password') }}</p> Note All definitions will remain local to the page. It is possible to define Jinja2 macros in a separate file, and to import them from there in any page, using the {% import ..} directive. See explanations under Advanced Usage . Conditionals, loops, etc. With the macros plugin, you may use the conditional statement of Jinja2, e.g. ### My title {% if == 'bar' %} We will write this **first version** {% else %} _Second version_ {% endif %} You may produce Markdown or any mix of Markdown, HTML, css and even javascript that you wish. Similarly, you could use for loops : ### List of users {% set users = ['joe', 'jill', 'david', 'sam'] %} {% for user in users %} 1. {{ user }} {% endfor %} In fact, you can do all the fancy footwork you want with Jinja2 !","title":"Rich Markdown Pages"},{"location":"pages/#how-to-write-enriched-markdown-pages","text":"","title":"How to Write \"Enriched\" Markdown Pages"},{"location":"pages/#definitions","text":"","title":"Definitions"},{"location":"pages/#1-variable","text":"A variable is a predefined value. The primary source of variables is the extra namespace in the config file (by default: mkdocs.yml ). You can add variables in the Python module. Also local variables can be added directly to each markdown page, thanks to jinja2 directives, called set (those local variables are accessible by jinja2 directives, but not the Python code).","title":"1. Variable"},{"location":"pages/#2-macro","text":"We call macros , Python functions (or callables) that will be used in jinja2 snippets within the markdown pages. A macro should return a string that can be plain, markdown or HTML. Each call to the macro in markdown page will be replaced by that result. Note For more information on the full concept of a macro, see the detailed explanation .","title":"2. Macro"},{"location":"pages/#3-filter","text":"A custom filter is a Jinja2 concept. It is essentially a Python function used with a different syntax, e.g. {{ 'my text ' | uppercase}} (supposing there was a custom function called uppercase and declared as a filter). Just as a macro, a filter should return a string that can be plain, markdown or HTML.","title":"3. Filter"},{"location":"pages/#batteries-included-defaut-objects","text":"The following objects are, in particular, available by default, with their set of attributes: Object Description config The standard config information on MkDocs' environment. page Info on the current page ( source ) navigation List of all pages/sections of the website; sections are themselves list of pages; ( source ) environment Data on the system on which MkDocs is currently running. plugin Arguments of the macro plugin, in the config file git Information on the git version of the website (if part of a git repository) files The file structure (for advanced users who know how to manipulate the mkdocs.structure.files.Files object, as well as mkdocs.structure.files.File objects) For example, {{ config.site_name }} returns the main title of the website {{ environment.system }} returns the name of the OS. {{ navigation.pages }} returns a flattened list of all pages {{ plugin.module }} name of the Python module To discover what each of these objects contain, you can use the pretty filter provided with the plugin, e.g.: {{ context(page) | pretty }}","title":"\"Batteries included\": defaut objects"},{"location":"pages/#configuration-variables","text":"To easily and quickly define custom variables, declare them in you mkdocs.yml file: extra: price: 12.50 company: name: Acme address: .... website: www.acme.com In your markdown file: The price of the product is {{ price }}. See [more information on the website]({{ company.website }}). See <a href=\"{{ company.website }}\">more information on the website</a>.","title":"Configuration variables"},{"location":"pages/#local-page-level-variables-and-macros","text":"If you really need a variable or macro that needs to remain local to the markdown page, you can use a standard Jinja2 declaration. Warning Note that the context() macro (for listing variables) will not display variables defined at page level.","title":"Local (page-level) variables and macros"},{"location":"pages/#in-the-yaml-header-of-the-page","text":"Variables defined in the YAML header of the page are accessible as themselves and via the page.meta object. For example, if the the header is as follows: --- title: My special title bottles: whine: 500 beer: 123 --- Then you can access the content of the YAML header in two ways: By name e.g. {{ title }} and {{ bottles.whine }} Explicitly, i.e. using the dot notation, e.g. {{ page.meta.title }} and {{ page.meta.bottles.whine }} . Tip {{ page.meta }} gives the content of the header. If you wish to have it typed in a nice tabular form, you can use: {{ context(page.meta) | pretty }} Caution If variables in the metadata have the same name as variables already defined (suche as extra , config , etc.) those will be overwritten, but for this page only.","title":"In the YAML header of the page"},{"location":"pages/#using-the-set-keyword","text":"Variables can be defined in the template with the set keyword, e.g.: {% set acme = 'Acme Company Ltd' %} Please buy the great products from {{ acme }}! Contrary to variables defined in the extra section of the mkdocs.yml file, they are accessible only within the specific page. They are not accessible from the python code. Tip If you need reference information on the page, there is a page object e.g.: {{ page.title }} , {{ page.url }} , {{ page.is_homepage }} , etc.","title":"Using the set keyword"},{"location":"pages/#page-level-macros","text":"It is possible to write Jinja2 macros written with the Jinja2 syntax (instead of a Python module). This allows you benefit from the power of that language for the manipulation of strings. Here is an example of Jinja2 macro, from the official documentation: {% macro input(name, value='', type='text', size=20) -%} <input type=\"{{ type }}\" name=\"{{ name }}\" value=\"{{ value|e }}\" size=\"{{ size }}\"> {%- endmacro %} Which can be called (within the page) as: <p>{{ input('username') }}</p> <p>{{ input('password', type='password') }}</p> Note All definitions will remain local to the page. It is possible to define Jinja2 macros in a separate file, and to import them from there in any page, using the {% import ..} directive. See explanations under Advanced Usage .","title":"Page-level macros"},{"location":"pages/#conditionals-loops-etc","text":"With the macros plugin, you may use the conditional statement of Jinja2, e.g. ### My title {% if == 'bar' %} We will write this **first version** {% else %} _Second version_ {% endif %} You may produce Markdown or any mix of Markdown, HTML, css and even javascript that you wish. Similarly, you could use for loops : ### List of users {% set users = ['joe', 'jill', 'david', 'sam'] %} {% for user in users %} 1. {{ user }} {% endfor %} In fact, you can do all the fancy footwork you want with Jinja2 !","title":"Conditionals, loops, etc."},{"location":"pluglets/","text":"Writing pluglets Note New, as of version 0.4.20. Introduction Definition A pluglet is a preinstalled module for mkdocs-macros, which is installed thanks to Pythons standard packaging process . The only thing needed (as a bare minimum), is to implement a single function, define_env() : def define_env(env): .... What makes a pluglet different from a plain module? The only difference between a pluglet and an ordinary mkdocs-macros module (typically main.py or main directory), is that the pluglet is preinstalled. In this way, you can benefit from pluglets written by others, and you could share the pluglets that you wrote. A pluglet can do two things that any mkdocs-macro module can do: Define macros. Perform changes on the architecture of the website. What makes a pluglet different from a plugin? A pluglet is distinct from an MkDocs plugin . A pluglet is a more lightweight tool that sits over the mkdocs-macros plugin and uses the framework provided by it. There is no need to implement a subclass of the BasePlugin class, only to declare a define_env(env) function. Could a pluglet do everything a plugin can do? The answer is, quite a lot, but not everything . MkDocs plugins are able to rely on a wide range of events , which are hooks for acting on the website at various stages of the config/build process. A mkdocs-macros pluglet operates mostly on the on_config event of MkDocs thanks to define_env(env) hook; but its use can be extended thanks to other hooks . Using existing pluglets Declaring a pluglet for an MkDocs project For your specific documentation project, you may call already installed pluglets (which would appear with pip list ): pip list | grep mkdocs-macros Use the modules argument. It is a list, so that you can declare one or more: e.g. : plugins: ... - macros: modules: [mkdocs_macros_test] or: plugins: ... - macros: modules: [mkdocs_macros_foo, mkdocs_macros_bar] Auto-installable pluglets Every pluglet specified in the modules list should be available. However, if the pluglet cannot be found, mkdocs will attempt to install it (with pip3 install ) from the standard repositories ( Pypi and others defined locally ). If not, mkdocs will fail and exit. Make installations easier! The purpose of this feature is to facilitate the management of environments with several mkdocs websites, typically when a pluglet is designed for a whole company, project, etc. In this way, the macros and filters declared in the pluglet will work out of the box, as long as the pluglet is properly defined in the config file (and the pluglet is auto-installable). In some cases, the name of the source package i: plugins: ... - macros: modules: [mkdocs-macros-test:mkdocs_macros_test] In the example above mkdocs-macros-test is the package source, and mkdocs_macros_test is the package name for the import statement. If those names are correct everything should fall into place when you type the mkdocs serve or mkdocs build commands. Implementing a new pluglet General Principles You can develop pluglets for mkdocs-macros-plugin and publish them on github and pypi . How to name a pluglet The names for pluglets are not constrained. As a naming convention , we strongly recommend: a package name starting with mkdocs-macros- an import name starting mkdocs_macros_ , i.e. replacing the hyphen ( - ) symbol by underscore ( _ ). Typical structure of a pluglet Note You will find a simple example with the mkdocs-test pluglet, available on gihub . The setup.py file will typically have this form: from setuptools import setup setup( name='mkdocs-macros-foo', version='0.0.1', description=\"Foo library for macros plugin\", packages=['mkdocs_macros_foo'], license='<YOUR CHOICE>', author='Joe Bloe' ) The structure will be typically like so: \u251c\u2500\u2500 LICENSE.md \u251c\u2500\u2500 README.md \u251c\u2500\u2500 mkdocs_macros_test.py \u2514\u2500\u2500 setup.py or like so (if it is more complex): \u251c\u2500\u2500 LICENSE.md \u251c\u2500\u2500 README.md \u251c\u2500\u2500 mkdocs_macros_test \u2502 \u2514\u2500\u2500 __init__.py | \u2514\u2500\u2500 util.py \u2514\u2500\u2500 setup.py Note The subdirectory containing the code will have to be called mkdocs_macros_foo (underscores). How to write the code For the code itself, proceed as for a usual module : \"\"\" Code of the pluglet \"\"\" def test_fn(x:float): \"Test function\" return x * 4 / 3 def say_hello(s:str): \"Test procedure\" return \"<i>Hello %s</i>\" % s def define_env(env): \"Declare environment for jinja2 templates for markdown\" for fn in [test_fn, say_hello]: env.macro(fn) # you could, of course, also define a macro here: @env.macro def test_fn2(s:str): return \"I am displaying this: %s\" % s","title":"Writing pluglets"},{"location":"pluglets/#writing-pluglets","text":"Note New, as of version 0.4.20.","title":"Writing pluglets"},{"location":"pluglets/#introduction","text":"","title":"Introduction"},{"location":"pluglets/#definition","text":"A pluglet is a preinstalled module for mkdocs-macros, which is installed thanks to Pythons standard packaging process . The only thing needed (as a bare minimum), is to implement a single function, define_env() : def define_env(env): .... What makes a pluglet different from a plain module? The only difference between a pluglet and an ordinary mkdocs-macros module (typically main.py or main directory), is that the pluglet is preinstalled. In this way, you can benefit from pluglets written by others, and you could share the pluglets that you wrote. A pluglet can do two things that any mkdocs-macro module can do: Define macros. Perform changes on the architecture of the website. What makes a pluglet different from a plugin? A pluglet is distinct from an MkDocs plugin . A pluglet is a more lightweight tool that sits over the mkdocs-macros plugin and uses the framework provided by it. There is no need to implement a subclass of the BasePlugin class, only to declare a define_env(env) function. Could a pluglet do everything a plugin can do? The answer is, quite a lot, but not everything . MkDocs plugins are able to rely on a wide range of events , which are hooks for acting on the website at various stages of the config/build process. A mkdocs-macros pluglet operates mostly on the on_config event of MkDocs thanks to define_env(env) hook; but its use can be extended thanks to other hooks .","title":"Definition"},{"location":"pluglets/#using-existing-pluglets","text":"","title":"Using existing pluglets"},{"location":"pluglets/#declaring-a-pluglet-for-an-mkdocs-project","text":"For your specific documentation project, you may call already installed pluglets (which would appear with pip list ): pip list | grep mkdocs-macros Use the modules argument. It is a list, so that you can declare one or more: e.g. : plugins: ... - macros: modules: [mkdocs_macros_test] or: plugins: ... - macros: modules: [mkdocs_macros_foo, mkdocs_macros_bar]","title":"Declaring a pluglet for an MkDocs project"},{"location":"pluglets/#auto-installable-pluglets","text":"Every pluglet specified in the modules list should be available. However, if the pluglet cannot be found, mkdocs will attempt to install it (with pip3 install ) from the standard repositories ( Pypi and others defined locally ). If not, mkdocs will fail and exit. Make installations easier! The purpose of this feature is to facilitate the management of environments with several mkdocs websites, typically when a pluglet is designed for a whole company, project, etc. In this way, the macros and filters declared in the pluglet will work out of the box, as long as the pluglet is properly defined in the config file (and the pluglet is auto-installable). In some cases, the name of the source package i: plugins: ... - macros: modules: [mkdocs-macros-test:mkdocs_macros_test] In the example above mkdocs-macros-test is the package source, and mkdocs_macros_test is the package name for the import statement. If those names are correct everything should fall into place when you type the mkdocs serve or mkdocs build commands.","title":"Auto-installable pluglets"},{"location":"pluglets/#implementing-a-new-pluglet","text":"","title":"Implementing a new pluglet"},{"location":"pluglets/#general-principles","text":"You can develop pluglets for mkdocs-macros-plugin and publish them on github and pypi .","title":"General Principles"},{"location":"pluglets/#how-to-name-a-pluglet","text":"The names for pluglets are not constrained. As a naming convention , we strongly recommend: a package name starting with mkdocs-macros- an import name starting mkdocs_macros_ , i.e. replacing the hyphen ( - ) symbol by underscore ( _ ).","title":"How to name a pluglet"},{"location":"pluglets/#typical-structure-of-a-pluglet","text":"Note You will find a simple example with the mkdocs-test pluglet, available on gihub . The setup.py file will typically have this form: from setuptools import setup setup( name='mkdocs-macros-foo', version='0.0.1', description=\"Foo library for macros plugin\", packages=['mkdocs_macros_foo'], license='<YOUR CHOICE>', author='Joe Bloe' ) The structure will be typically like so: \u251c\u2500\u2500 LICENSE.md \u251c\u2500\u2500 README.md \u251c\u2500\u2500 mkdocs_macros_test.py \u2514\u2500\u2500 setup.py or like so (if it is more complex): \u251c\u2500\u2500 LICENSE.md \u251c\u2500\u2500 README.md \u251c\u2500\u2500 mkdocs_macros_test \u2502 \u2514\u2500\u2500 __init__.py | \u2514\u2500\u2500 util.py \u2514\u2500\u2500 setup.py Note The subdirectory containing the code will have to be called mkdocs_macros_foo (underscores).","title":"Typical structure of a pluglet"},{"location":"pluglets/#how-to-write-the-code","text":"For the code itself, proceed as for a usual module : \"\"\" Code of the pluglet \"\"\" def test_fn(x:float): \"Test function\" return x * 4 / 3 def say_hello(s:str): \"Test procedure\" return \"<i>Hello %s</i>\" % s def define_env(env): \"Declare environment for jinja2 templates for markdown\" for fn in [test_fn, say_hello]: env.macro(fn) # you could, of course, also define a macro here: @env.macro def test_fn2(s:str): return \"I am displaying this: %s\" % s","title":"How to write the code"},{"location":"tips/","text":"Tips and Tricks How can I get the project's document directory? This would be the main directory where the project's markdown pages are located. From a markdown page: {{ config.docs_dir }} From the macro module ( main.py ): env.conf['docs_dir'] Note env.conf is a pure dictionary (no dot notation in Python) In Python, you could also access that information through env.variables.config['docs_dir'] , but that is more complicated... Is there some function or variable for information XYZ? If you cannot find an answer in this readme, use macros_info() to display the information on all the variables, functions and filters available in a page. It would be great if XY function was available in mkdocs-macro... Have you considered writing your own macro in Python ? It's quick and easy. Seriously: macros are easy to write Generating HTML to enrich a page, for adding additional git information, listing the content of files, etc.: if you know how to write a Python function, you can turn it into a macro . How can I access git information? See the page on git . How do I deal with relative links to documents/images? Issues A general problem with MkDocs is that you may encounter problems when referring to other pages. Suppose you want to refer to another page foo.md in the same directory (undermarkdown). This will NOT work with hyperlinks Intuitively one would write: See this [other page](foo) ![This is an image](image.jpg) Unfortunately, this is NOT going to work ! Correct way with hyperlinks The correct way is: See this [other page](../foo) ![This is an image](../image.jpg) Explanation Let's remember that html files are organized differently than their markdown counterparts. If we consider the project's directory as the root directory: a page in /docs/foo.md will be translated into /site/foo/index.html an attachment in /docs/attachments/foo.pdf will be copied under /site/attachments/foo.pdf The consequence is that a link to an attachment currently in /docs/attachment/foo.pdf , e.g.: <a href=\"attachments/foo.pdf\">click here</a> will not work . You would have to write instead: <a href=\"../attachments/foo.pdf\">click here</a> which is unintuitive, and therefore error prone. The fix_url() function The purpose of fix_url() is to capture relative urls and lift them up one level. Supposing you had an attachment directory just under the docs directory, then a pdf could be accessed with attachments/foo.pdf , as you would in markdown . You could write, e.g. a macro: # note the spelling of mkdocs_macros in Python programs (underscore): from mkdocs_macros import fix_url def define_env(env): \"Define macros...\" @macro def image(url:str, alt:str='') url = fix_url(url) return '<img src=\"%s\", alt=\"%s\"> If you called, as you would expect: {{ image('foo.jpg', alt='A foo image')}} Then this would be translated as: <img src=\"../foo.jpg\", alt=\"A foo image\"> Tip The fix_url() function will only fix relative links, and leave other ones (e.g. https://... unchanged). How can I create a button? In the python module, add to the define_env() function: def define_env(env): # import the predefined macro fix_url = env.variables.fix_url # make relative urls point to root @env.macro def button(label, url): \"Add a button\" url = fix_url(url) HTML = \"\"\"<a class='button' href=\"%s\">%s</a>\"\"\" return HTML % (url, label) In your markdown page: {{ button('Try this', 'http:your.website.com/page') }} Hyperlinks in HTML The fix_url() function is there to fix relative URLs so that they seem to work as in markdown, i.e. relative paths are in reference to the docs directory (other types of URLs are left unchanged). See more information on the subject of relative links . I would like to include a text file, from line a to line b In the source directory of your MkDocs project (where mkdocs.yml generally is), create a file main.py : import os def define_env(env): \"\"\" This is the hook for defining variables, macros and filters - variables: the dictionary that contains the environment variables - macro: a decorator function, to declare a macro. \"\"\" @env.macro def include_file(filename, start_line=0, end_line=None): \"\"\" Include a file, optionally indicating start_line and end_line (start counting from 0) The path is relative to the top directory of the documentation project. \"\"\" full_filename = os.path.join(env.project_dir, filename) with open(full_filename, 'r') as f: lines = f.readlines() line_range = lines[start_line:end_line] return ''.join(line_range) Tip Note how we used env.project_dir to identify the source directory of the website's project. Caution To keep things simple, this solution reads the whole file into memory; so it should not be used for huge files. In your markdown page, add the call: Here is the description: ``` {{ include_file('mkdocs.yml', 0, 4) }} ``` Restart the mkdocs server (or rebuild the website) and voil\u00e0 , you have the first five lines of your file! How can I discover all attributes and methods of the env object? To discover all items available in the environment available, for writing custom macros, you could declare the following macro: def define_env(env): \"\"\" This is the hook for the functions (new form) \"\"\" @env.macro def doc_env(): \"Document the environment\" return {name:getattr(env, name) for name in dir(env) if not name.startswith('_')} And call it in witin a mardkown page: ``` {{ doc_env() | pprint }} ``` This gives the whole range of information available within a page. Warning It is probably not a good idea to expose the env object to web pages, so you should think twice before using this macro in a production environment. While the consequences of exposing the env object (or worse, altering it) have not been explored, there is likely a good potential for mischief. Whatever you do with this object, is at your own peril. Can I use my code editor's auto-discovery function in a module? Yes. If your code editor is smart enough to provide auto-completion, then you can make your life much easier, by giving a type hint to your declare_env() function: from mkdocs_macros import MacrosPlugin def define_env(env:MacrosPlugin): \"Definition of the module\" ... In this way, you will benefit from \"auto-discovery\" each time you invoke the env object. Indeed, env belongs to the MacrosPlugin class, which is itself a subclass of MkDocs' BasePlugin class . Caution Note that you cannot use the help() function from the Python interpreter console as this raises an error: >>> from mkdocs_macros import MacrosPlugin >>> help(MacrosPlugin) This is a behavior inherited from the the MkDocs BasePlugin class.","title":"Tips and Tricks"},{"location":"tips/#tips-and-tricks","text":"","title":"Tips and Tricks"},{"location":"tips/#how-can-i-get-the-projects-document-directory","text":"This would be the main directory where the project's markdown pages are located. From a markdown page: {{ config.docs_dir }} From the macro module ( main.py ): env.conf['docs_dir'] Note env.conf is a pure dictionary (no dot notation in Python) In Python, you could also access that information through env.variables.config['docs_dir'] , but that is more complicated...","title":"How can I get the project's document directory?"},{"location":"tips/#is-there-some-function-or-variable-for-information-xyz","text":"If you cannot find an answer in this readme, use macros_info() to display the information on all the variables, functions and filters available in a page.","title":"Is there some function or variable for information XYZ?"},{"location":"tips/#it-would-be-great-if-xy-function-was-available-in-mkdocs-macro","text":"Have you considered writing your own macro in Python ? It's quick and easy. Seriously: macros are easy to write Generating HTML to enrich a page, for adding additional git information, listing the content of files, etc.: if you know how to write a Python function, you can turn it into a macro .","title":"It would be great if XY function was available in mkdocs-macro..."},{"location":"tips/#how-can-i-access-git-information","text":"See the page on git .","title":"How can I access git information?"},{"location":"tips/#how-do-i-deal-with-relative-links-to-documentsimages","text":"","title":"How do I deal with relative links to documents/images?"},{"location":"tips/#issues","text":"A general problem with MkDocs is that you may encounter problems when referring to other pages. Suppose you want to refer to another page foo.md in the same directory (undermarkdown). This will NOT work with hyperlinks Intuitively one would write: See this [other page](foo) ![This is an image](image.jpg) Unfortunately, this is NOT going to work ! Correct way with hyperlinks The correct way is: See this [other page](../foo) ![This is an image](../image.jpg)","title":"Issues"},{"location":"tips/#explanation","text":"Let's remember that html files are organized differently than their markdown counterparts. If we consider the project's directory as the root directory: a page in /docs/foo.md will be translated into /site/foo/index.html an attachment in /docs/attachments/foo.pdf will be copied under /site/attachments/foo.pdf The consequence is that a link to an attachment currently in /docs/attachment/foo.pdf , e.g.: <a href=\"attachments/foo.pdf\">click here</a> will not work . You would have to write instead: <a href=\"../attachments/foo.pdf\">click here</a> which is unintuitive, and therefore error prone.","title":"Explanation"},{"location":"tips/#the-fix_url-function","text":"The purpose of fix_url() is to capture relative urls and lift them up one level. Supposing you had an attachment directory just under the docs directory, then a pdf could be accessed with attachments/foo.pdf , as you would in markdown . You could write, e.g. a macro: # note the spelling of mkdocs_macros in Python programs (underscore): from mkdocs_macros import fix_url def define_env(env): \"Define macros...\" @macro def image(url:str, alt:str='') url = fix_url(url) return '<img src=\"%s\", alt=\"%s\"> If you called, as you would expect: {{ image('foo.jpg', alt='A foo image')}} Then this would be translated as: <img src=\"../foo.jpg\", alt=\"A foo image\"> Tip The fix_url() function will only fix relative links, and leave other ones (e.g. https://... unchanged).","title":"The fix_url() function"},{"location":"tips/#how-can-i-create-a-button","text":"In the python module, add to the define_env() function: def define_env(env): # import the predefined macro fix_url = env.variables.fix_url # make relative urls point to root @env.macro def button(label, url): \"Add a button\" url = fix_url(url) HTML = \"\"\"<a class='button' href=\"%s\">%s</a>\"\"\" return HTML % (url, label) In your markdown page: {{ button('Try this', 'http:your.website.com/page') }} Hyperlinks in HTML The fix_url() function is there to fix relative URLs so that they seem to work as in markdown, i.e. relative paths are in reference to the docs directory (other types of URLs are left unchanged). See more information on the subject of relative links .","title":"How can I create a button?"},{"location":"tips/#i-would-like-to-include-a-text-file-from-line-a-to-line-b","text":"In the source directory of your MkDocs project (where mkdocs.yml generally is), create a file main.py : import os def define_env(env): \"\"\" This is the hook for defining variables, macros and filters - variables: the dictionary that contains the environment variables - macro: a decorator function, to declare a macro. \"\"\" @env.macro def include_file(filename, start_line=0, end_line=None): \"\"\" Include a file, optionally indicating start_line and end_line (start counting from 0) The path is relative to the top directory of the documentation project. \"\"\" full_filename = os.path.join(env.project_dir, filename) with open(full_filename, 'r') as f: lines = f.readlines() line_range = lines[start_line:end_line] return ''.join(line_range) Tip Note how we used env.project_dir to identify the source directory of the website's project. Caution To keep things simple, this solution reads the whole file into memory; so it should not be used for huge files. In your markdown page, add the call: Here is the description: ``` {{ include_file('mkdocs.yml', 0, 4) }} ``` Restart the mkdocs server (or rebuild the website) and voil\u00e0 , you have the first five lines of your file!","title":"I would like to include a text file, from line a to line b"},{"location":"tips/#how-can-i-discover-all-attributes-and-methods-of-the-env-object","text":"To discover all items available in the environment available, for writing custom macros, you could declare the following macro: def define_env(env): \"\"\" This is the hook for the functions (new form) \"\"\" @env.macro def doc_env(): \"Document the environment\" return {name:getattr(env, name) for name in dir(env) if not name.startswith('_')} And call it in witin a mardkown page: ``` {{ doc_env() | pprint }} ``` This gives the whole range of information available within a page. Warning It is probably not a good idea to expose the env object to web pages, so you should think twice before using this macro in a production environment. While the consequences of exposing the env object (or worse, altering it) have not been explored, there is likely a good potential for mischief. Whatever you do with this object, is at your own peril.","title":"How can I discover all attributes and methods of the env object?"},{"location":"tips/#can-i-use-my-code-editors-auto-discovery-function-in-a-module","text":"Yes. If your code editor is smart enough to provide auto-completion, then you can make your life much easier, by giving a type hint to your declare_env() function: from mkdocs_macros import MacrosPlugin def define_env(env:MacrosPlugin): \"Definition of the module\" ... In this way, you will benefit from \"auto-discovery\" each time you invoke the env object. Indeed, env belongs to the MacrosPlugin class, which is itself a subclass of MkDocs' BasePlugin class . Caution Note that you cannot use the help() function from the Python interpreter console as this raises an error: >>> from mkdocs_macros import MacrosPlugin >>> help(MacrosPlugin) This is a behavior inherited from the the MkDocs BasePlugin class.","title":"Can I use my code editor's auto-discovery function in a module?"},{"location":"troubleshooting/","text":"Troubleshooting Before anything else Important Make sure you you have the last version of mkdocs-macros. Perhaps the issue is already fixed? Also, check that your version of mkdocs is sufficiently up-to-date. What happens if a variable is undefined? New on 0.6.4. The default behavior in case of undefined variable is called keep (DebugUndefined): Unknown variables are rendered as is ( {{ foobar }} will be printed as such if foobar is undefined). Any other cases (notably unknown attribute or function call) will cause the page to fail (be rendered with an error message within the page plus the traceback). Tip There were two reasons for adopting this behavior: This \"debug\" mode reduces cognitive overhead in case of misspelled variable. Anyone will be able to detect this error (it is better having an odd jinja2 statement in the page than having a \"blank\" that is likely to go unnoticed) Other plugins than mkdocs-macros make use of jinja2 variables (as specified in the config file). In this way, mkdocs-macros will not \"eat up\" those variables; it will give other plugins a better chance to work. You may alter this behavior with the on_undefined parameter in mkdocs_macros section of the config file ( mkdocs.yaml ): Value Definition Undefined Type keep (Default) Unknown variables are rendered as-is; all other cases will cause the page to fail. DebugUndefined silent Unknown variables are rendered as blank; all other cases will cause the page to fail. Undefined strict Anything incorrect will cause the page to fail (closest behavior to Python). StrictUndefined lax Like silent (blank); will be more tolerant, typically in case of unknown attribute. LaxUndefined ( specific to mkdocs-macros ) Warning A call to an unknown macro (callable) will always cause the page to fail. The Undefined Type is the Jinja2 class used to implement that behavior (see definition in official documentation ). Error Information in case of module error In principle a rendering error in a macro will not stop the server, but display the error in the browser's page (as you would expect, e.g. with php). The terminal's running log also displays errors when they occur. macros_info() as the go-to tool Adding following line in a page: {{ macros_info() }} and restarting the server in the terminal with mkdocs serve will usually give you a wealth of information within the browser: If the information page appears (as e.g. phpinfo() for php), then you know that the plugin must be working. If the page displays and an error message appears, then there may be a problem either with the page or with the plugin's installation. If the page does not display at all, then the mkdocs server might not be running or there can be a problem running it. How can I get detailed debug information on an object? For example, if you want to have more information on the config object: {{ context('config') | pretty }} (the pretty filter displays the result in a nice table form) You can use this pattern for pretty much any object, even those you declared in a module. When used on its own, context() gives the general list of variables in the plugin's environment: {{ context() | pretty }} Help! mkdocs-macros is breaking down or eating pieces of my documentation! Note In principle, anything that looks like an unknown variable (e.g. {{ foo }} ) will be preserved. But in some cases there could be a broken page or an empty string where you expected one . A likely cause to the problem is that mkdocs-macros is believing that statements of the form \\{\\{ .... }} or {% ... %} in your pages, which you want to appear in the HTML output or be processed by another plugin, are intended for it. For the solutions to that problem, see how to prevent interpretation of Jinja-like statements . Traces on the console From version 0.5.0 Using the console's traces for troubleshooting To make troubleshooting while using mkdocs serve you do not need to rely only on what you see in the browser. You should exploit the trace on the console, which MkDocs-macros produces on the fly. The statements specific to mkdocs-macros appear with a [macros] prefix e.g.: INFO - [macros] - Macros arguments: {'module_name': 'main', 'modules': ['mkdocs_macros_test'], 'include_dir': 'include', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': '', 'verbose': False} Tip Reading the console's trace may help you follow up what is happening. Hiding mkdocs-macros' trace You can suppress the trace completely (together with the rest of the INFO trace from mkdocs), with the standard --quiet option : mkdocs serve --quiet or with the -q option. Debug mode for mkdocs-macros You can increase the trace completely by showing the debug information (together with the rest of the DEBUG from mkdocs), with the standard --verbose option: mkdocs serve --verbose or with the -v option. Verbose (debug) statements in macros You could use print() statements to log what is happening in your macros, and it is going to be printed on the console. But this can be messy . It is much better, within the def define_env(): declaration, to use the chatter() function. It will print statements only if the macros plugin's debug mode is set to true. plugins: - ... - macros: verbose: true Tip With the chatter() function, you can leave those debug traces in the code of your macros, and visualize them only when you want to see them. You need to first declare the chatter() function with the env.start_chatting() method. This initialization is necessary, so that you can give a nickname for your module, which will allow you to recognize the traces: def define_env(env): \"\"\" This is the hook for the functions (new form) \"\"\" # activate trace chatter = env.start_chatting(\"Simple module\") ... chatter(\"This is a dull statement.\") This will print: INFO - [macros - Simple module] - This is a dull statement. Important The verbose mode for mkdocs-macros is distinct from the general debug mode of mkdocs (which is activated with the --verbose option). To activate the debug mode for mkdocs-macros, you need to set the verbose option to true for mkdocs-macros, in the config file ( mkdocs.yml ). Toggling between true and false in the verbose option will be immediately be reflected on the console. Forcibly suppressing the console output of macros If the verbose argument is set to true for the plugin, the messages will appear as INFO on the console's log. It means that if you suppress the trace output at the level of mkdocs serve (using the --quiet option), this will also suppress the trace for your macros . This is intentional, so that the behavior of MkDocs's logging remains entirely predictable, even for people who never heard of mkdocs-macros (principle of least astonishment) Where Can I get Help? Issues Check the issues on the github repo. Tips Some issues have the marker Useful Tip . Also check the closed issues . It could be that your issue has already been solved and closed! Also, you could check similar questions, to see if they could point you to the right questions. If you want to add a new issue (for a bug or an enhancement request), or comment on an existing one, you are more than welcome! All issues are carefully reviewed and often get a quick answer. If all else fails... If you still have questions: Check the Q&As \ud83d\ude4f in the project's Discussions space, on github . Post a Q&A \ud83d\ude4f item!","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#before-anything-else","text":"Important Make sure you you have the last version of mkdocs-macros. Perhaps the issue is already fixed? Also, check that your version of mkdocs is sufficiently up-to-date.","title":"Before anything else"},{"location":"troubleshooting/#what-happens-if-a-variable-is-undefined","text":"New on 0.6.4. The default behavior in case of undefined variable is called keep (DebugUndefined): Unknown variables are rendered as is ( {{ foobar }} will be printed as such if foobar is undefined). Any other cases (notably unknown attribute or function call) will cause the page to fail (be rendered with an error message within the page plus the traceback). Tip There were two reasons for adopting this behavior: This \"debug\" mode reduces cognitive overhead in case of misspelled variable. Anyone will be able to detect this error (it is better having an odd jinja2 statement in the page than having a \"blank\" that is likely to go unnoticed) Other plugins than mkdocs-macros make use of jinja2 variables (as specified in the config file). In this way, mkdocs-macros will not \"eat up\" those variables; it will give other plugins a better chance to work. You may alter this behavior with the on_undefined parameter in mkdocs_macros section of the config file ( mkdocs.yaml ): Value Definition Undefined Type keep (Default) Unknown variables are rendered as-is; all other cases will cause the page to fail. DebugUndefined silent Unknown variables are rendered as blank; all other cases will cause the page to fail. Undefined strict Anything incorrect will cause the page to fail (closest behavior to Python). StrictUndefined lax Like silent (blank); will be more tolerant, typically in case of unknown attribute. LaxUndefined ( specific to mkdocs-macros ) Warning A call to an unknown macro (callable) will always cause the page to fail. The Undefined Type is the Jinja2 class used to implement that behavior (see definition in official documentation ).","title":"What happens if a variable is undefined?"},{"location":"troubleshooting/#error-information-in-case-of-module-error","text":"In principle a rendering error in a macro will not stop the server, but display the error in the browser's page (as you would expect, e.g. with php). The terminal's running log also displays errors when they occur.","title":"Error Information in case of module error"},{"location":"troubleshooting/#macros_info-as-the-go-to-tool","text":"Adding following line in a page: {{ macros_info() }} and restarting the server in the terminal with mkdocs serve will usually give you a wealth of information within the browser: If the information page appears (as e.g. phpinfo() for php), then you know that the plugin must be working. If the page displays and an error message appears, then there may be a problem either with the page or with the plugin's installation. If the page does not display at all, then the mkdocs server might not be running or there can be a problem running it.","title":"macros_info() as the go-to tool"},{"location":"troubleshooting/#how-can-i-get-detailed-debug-information-on-an-object","text":"For example, if you want to have more information on the config object: {{ context('config') | pretty }} (the pretty filter displays the result in a nice table form) You can use this pattern for pretty much any object, even those you declared in a module. When used on its own, context() gives the general list of variables in the plugin's environment: {{ context() | pretty }}","title":"How can I get detailed debug information on an object?"},{"location":"troubleshooting/#help-mkdocs-macros-is-breaking-down-or-eating-pieces-of-my-documentation","text":"Note In principle, anything that looks like an unknown variable (e.g. {{ foo }} ) will be preserved. But in some cases there could be a broken page or an empty string where you expected one . A likely cause to the problem is that mkdocs-macros is believing that statements of the form \\{\\{ .... }} or {% ... %} in your pages, which you want to appear in the HTML output or be processed by another plugin, are intended for it. For the solutions to that problem, see how to prevent interpretation of Jinja-like statements .","title":"Help! mkdocs-macros is breaking down or eating pieces of my documentation!"},{"location":"troubleshooting/#traces-on-the-console","text":"From version 0.5.0","title":"Traces on the console"},{"location":"troubleshooting/#using-the-consoles-traces-for-troubleshooting","text":"To make troubleshooting while using mkdocs serve you do not need to rely only on what you see in the browser. You should exploit the trace on the console, which MkDocs-macros produces on the fly. The statements specific to mkdocs-macros appear with a [macros] prefix e.g.: INFO - [macros] - Macros arguments: {'module_name': 'main', 'modules': ['mkdocs_macros_test'], 'include_dir': 'include', 'include_yaml': [], 'j2_block_start_string': '', 'j2_block_end_string': '', 'j2_variable_start_string': '', 'j2_variable_end_string': '', 'verbose': False} Tip Reading the console's trace may help you follow up what is happening.","title":"Using the console's traces for troubleshooting"},{"location":"troubleshooting/#hiding-mkdocs-macros-trace","text":"You can suppress the trace completely (together with the rest of the INFO trace from mkdocs), with the standard --quiet option : mkdocs serve --quiet or with the -q option.","title":"Hiding mkdocs-macros' trace"},{"location":"troubleshooting/#debug-mode-for-mkdocs-macros","text":"You can increase the trace completely by showing the debug information (together with the rest of the DEBUG from mkdocs), with the standard --verbose option: mkdocs serve --verbose or with the -v option.","title":"Debug mode for mkdocs-macros"},{"location":"troubleshooting/#verbose-debug-statements-in-macros","text":"You could use print() statements to log what is happening in your macros, and it is going to be printed on the console. But this can be messy . It is much better, within the def define_env(): declaration, to use the chatter() function. It will print statements only if the macros plugin's debug mode is set to true. plugins: - ... - macros: verbose: true Tip With the chatter() function, you can leave those debug traces in the code of your macros, and visualize them only when you want to see them. You need to first declare the chatter() function with the env.start_chatting() method. This initialization is necessary, so that you can give a nickname for your module, which will allow you to recognize the traces: def define_env(env): \"\"\" This is the hook for the functions (new form) \"\"\" # activate trace chatter = env.start_chatting(\"Simple module\") ... chatter(\"This is a dull statement.\") This will print: INFO - [macros - Simple module] - This is a dull statement. Important The verbose mode for mkdocs-macros is distinct from the general debug mode of mkdocs (which is activated with the --verbose option). To activate the debug mode for mkdocs-macros, you need to set the verbose option to true for mkdocs-macros, in the config file ( mkdocs.yml ). Toggling between true and false in the verbose option will be immediately be reflected on the console. Forcibly suppressing the console output of macros If the verbose argument is set to true for the plugin, the messages will appear as INFO on the console's log. It means that if you suppress the trace output at the level of mkdocs serve (using the --quiet option), this will also suppress the trace for your macros . This is intentional, so that the behavior of MkDocs's logging remains entirely predictable, even for people who never heard of mkdocs-macros (principle of least astonishment)","title":"Verbose (debug) statements in macros"},{"location":"troubleshooting/#where-can-i-get-help","text":"","title":"Where Can I get Help?"},{"location":"troubleshooting/#issues","text":"Check the issues on the github repo. Tips Some issues have the marker Useful Tip . Also check the closed issues . It could be that your issue has already been solved and closed! Also, you could check similar questions, to see if they could point you to the right questions. If you want to add a new issue (for a bug or an enhancement request), or comment on an existing one, you are more than welcome! All issues are carefully reviewed and often get a quick answer.","title":"Issues"},{"location":"troubleshooting/#if-all-else-fails","text":"If you still have questions: Check the Q&As \ud83d\ude4f in the project's Discussions space, on github . Post a Q&A \ud83d\ude4f item!","title":"If all else fails..."},{"location":"why/","text":"Why developing the macros plugin? Sources of inspiration mkdocs-markdownextradata (rosscdh) The idea for that extension came to me after I saw the excellent plugin mkdocs-markdownextradata created by rosscdh, which takes metadata data from the mkdocs.yml file, and allows you to insert them with double curly brackets: The price of the item is {{ price }}. His idea of using the jinja2 templating engine for that purpose was simple and beautiful: all it took for this plugin was a few lines of code. jinja2: variables can also be Python callables I then discovered that the creators of jinja2, in their great wisdom (thanks to them!), had decided to support any kind of Python variables, including callables , typically functions, e.g.: The price of the item is {{ calculate(2, 7.4) }}. Perhaps they did not think it was worth more than a few words in their documentation, but it was a diamond in plain sight. Idea Oh yeah? So let's call Python functions from the markdown pages of MkDocs! MkDocs + git = Wiki Engine Observation The idea of using 'macros' to speed up the process of writing web pages is in fact rather old and traces back to wiki engines . Wiki engines were defined around 1995 by Ward Cunningham as software based on the Wiki Principles , among which: Easy text entry, for which markdown is perfect Automatic link generation Content editable by all, whoever all means Recent changes Search a page by title and/or contents Quick diff (see the changes made to a wiki page) Page list (list all pages in the wiki) Back Link (find all pages pointing to a page) Thee simple principles were a revolution in the management of online documentation. Conclusion The combination of MkDocs + git easily answers all those criteria (with the possible exception of the last one), therefore it is a wiki engine . Macros in a Wiki Engine Observation Most wiki engines , which also rely on some markup language, had the same issue of enriching the markup language of their pages, at the turn of the year 2000. In response, they started implementing macros in one form or another (in mediawiki/Wikipedia, they are confusingly called templates ). And in many cases, these wiki engines already relied on the double-curly-braces syntax. The Weakness of Wiki Macros Wikis sometimes gave an impression that \"self-developed macros\" where impractical, because they were sometimes extremely difficult develop. Atlassian Confluence is a case in point, since writing macros for it requires Java development skills, as well as boilerplate code. Use Case: Overcoming the Intrinsic Limitations of Markdown Syntax MkDocs is a powerful, elegant and simple tool for generating websites. Pages are based on markdown , which is simple by design. The power and appeal of markdown comes from its extreme simplicity. Warning The downside of markdown's powerful simplicity is that its expressiveness necessarily limited. What do you do if you want to enrich markdown pages with features like buttons, fancy images, etc.? Solution 1: Markdown extensions In order to express more concepts with markdown, one possible recourse is to extend its through standard markdown extensions . Adding extensions to mkdocs is straightforward, since those extensions can be directly activated through the mkdocs.yml configuration file of the website e.g.: markdown_extensions: - footnotes Advantage Some markdown extensions, such as admonition are particularly powerful: !!! Note This is a note They are highly recommended. (If they are non-standard, you just have to install them first on your machine.) Problem The problem is, however, that there will always be something specific you will want to do, for which there is no markdown extension available. Or the extension will be too complicated, or not quite what you wanted. Furthermore, the are limitations to the number of possible extensions, because extending the grammar of markdown is always a little tricky. Some markdown extensions could alter what you meant with the standard markdown syntax (in other words, some markdown text you already wrote could be accidentally reinterpreted); or it could be incompatible with other extensions. Solution 2: Custom HTML Code If don't have an extension, the standard recourse is to write some pure HTML within your markdown, which may also contain some css code (especially if you are using css that is specific to your theme or website), e.g.: Here is my code: <a class='button' href=\"http://your.website.com/page\">Try this</a> The combination of HTML and css works well and can solve a wide range of issues. Problem But it will soon become tedious, if you have to type the same code again and again with some variations; and if you want to change something to the call (typically the css class), you will then have to manually change all instances of that code, with all the related risks. This solution doesn't scale. Solution 3: Enter Macros The Basic Idea A static website generator like mkdocs is nothing else than a wiki engine whose online editing features have been removed, to make it \"wiki-wikier\" (faster, leaner and meaner). What if mkdocs provided macros like a wiki engine, that would allow you to write the above HTML as: {{ button('Try this', 'http://your.website.com/page') }} ... that call was translated into the proper HTML? That would be something you could teach to a person who can already write markdown, without the need for them to get involved in any css or HTML! And, what's more, you could easily (as a programmer) write your own new macro in Python, whenever you needed one? Definition of a macro A macro is, simply stated, a Python function with arguments that returns a string. Macros are called from markdown pages. The result of each call to a macro is then embedded into the page, before mkdocs renders that page into a HTML page. A macro may contain all the logic required; it could be as simple as a button, or as sophisticated as making a query from a database and formatting the results as markdown or HTML. Macros bring to mkdocs the power and flexibility of macros from wiki engines, without their complexity. All of this becomes possible, thanks to mkdocs-macros-plugin !","title":"Why this project?"},{"location":"why/#why-developing-the-macros-plugin","text":"","title":"Why developing the macros plugin?"},{"location":"why/#sources-of-inspiration","text":"","title":"Sources of inspiration"},{"location":"why/#mkdocs-markdownextradata-rosscdh","text":"The idea for that extension came to me after I saw the excellent plugin mkdocs-markdownextradata created by rosscdh, which takes metadata data from the mkdocs.yml file, and allows you to insert them with double curly brackets: The price of the item is {{ price }}. His idea of using the jinja2 templating engine for that purpose was simple and beautiful: all it took for this plugin was a few lines of code.","title":"mkdocs-markdownextradata (rosscdh)"},{"location":"why/#jinja2-variables-can-also-be-python-callables","text":"I then discovered that the creators of jinja2, in their great wisdom (thanks to them!), had decided to support any kind of Python variables, including callables , typically functions, e.g.: The price of the item is {{ calculate(2, 7.4) }}. Perhaps they did not think it was worth more than a few words in their documentation, but it was a diamond in plain sight. Idea Oh yeah? So let's call Python functions from the markdown pages of MkDocs!","title":"jinja2: variables can also be Python callables"},{"location":"why/#mkdocs-git-wiki-engine","text":"Observation The idea of using 'macros' to speed up the process of writing web pages is in fact rather old and traces back to wiki engines . Wiki engines were defined around 1995 by Ward Cunningham as software based on the Wiki Principles , among which: Easy text entry, for which markdown is perfect Automatic link generation Content editable by all, whoever all means Recent changes Search a page by title and/or contents Quick diff (see the changes made to a wiki page) Page list (list all pages in the wiki) Back Link (find all pages pointing to a page) Thee simple principles were a revolution in the management of online documentation. Conclusion The combination of MkDocs + git easily answers all those criteria (with the possible exception of the last one), therefore it is a wiki engine .","title":"MkDocs + git = Wiki Engine"},{"location":"why/#macros-in-a-wiki-engine","text":"Observation Most wiki engines , which also rely on some markup language, had the same issue of enriching the markup language of their pages, at the turn of the year 2000. In response, they started implementing macros in one form or another (in mediawiki/Wikipedia, they are confusingly called templates ). And in many cases, these wiki engines already relied on the double-curly-braces syntax. The Weakness of Wiki Macros Wikis sometimes gave an impression that \"self-developed macros\" where impractical, because they were sometimes extremely difficult develop. Atlassian Confluence is a case in point, since writing macros for it requires Java development skills, as well as boilerplate code.","title":"Macros in a Wiki Engine"},{"location":"why/#use-case-overcoming-the-intrinsic-limitations-of-markdown-syntax","text":"MkDocs is a powerful, elegant and simple tool for generating websites. Pages are based on markdown , which is simple by design. The power and appeal of markdown comes from its extreme simplicity. Warning The downside of markdown's powerful simplicity is that its expressiveness necessarily limited. What do you do if you want to enrich markdown pages with features like buttons, fancy images, etc.?","title":"Use Case: Overcoming the Intrinsic Limitations of Markdown Syntax"},{"location":"why/#solution-1-markdown-extensions","text":"In order to express more concepts with markdown, one possible recourse is to extend its through standard markdown extensions . Adding extensions to mkdocs is straightforward, since those extensions can be directly activated through the mkdocs.yml configuration file of the website e.g.: markdown_extensions: - footnotes Advantage Some markdown extensions, such as admonition are particularly powerful: !!! Note This is a note They are highly recommended. (If they are non-standard, you just have to install them first on your machine.) Problem The problem is, however, that there will always be something specific you will want to do, for which there is no markdown extension available. Or the extension will be too complicated, or not quite what you wanted. Furthermore, the are limitations to the number of possible extensions, because extending the grammar of markdown is always a little tricky. Some markdown extensions could alter what you meant with the standard markdown syntax (in other words, some markdown text you already wrote could be accidentally reinterpreted); or it could be incompatible with other extensions.","title":"Solution 1: Markdown extensions"},{"location":"why/#solution-2-custom-html-code","text":"If don't have an extension, the standard recourse is to write some pure HTML within your markdown, which may also contain some css code (especially if you are using css that is specific to your theme or website), e.g.: Here is my code: <a class='button' href=\"http://your.website.com/page\">Try this</a> The combination of HTML and css works well and can solve a wide range of issues. Problem But it will soon become tedious, if you have to type the same code again and again with some variations; and if you want to change something to the call (typically the css class), you will then have to manually change all instances of that code, with all the related risks. This solution doesn't scale.","title":"Solution 2: Custom HTML Code"},{"location":"why/#solution-3-enter-macros","text":"The Basic Idea A static website generator like mkdocs is nothing else than a wiki engine whose online editing features have been removed, to make it \"wiki-wikier\" (faster, leaner and meaner). What if mkdocs provided macros like a wiki engine, that would allow you to write the above HTML as: {{ button('Try this', 'http://your.website.com/page') }} ... that call was translated into the proper HTML? That would be something you could teach to a person who can already write markdown, without the need for them to get involved in any css or HTML! And, what's more, you could easily (as a programmer) write your own new macro in Python, whenever you needed one? Definition of a macro A macro is, simply stated, a Python function with arguments that returns a string. Macros are called from markdown pages. The result of each call to a macro is then embedded into the page, before mkdocs renders that page into a HTML page. A macro may contain all the logic required; it could be as simple as a button, or as sophisticated as making a query from a database and formatting the results as markdown or HTML. Macros bring to mkdocs the power and flexibility of macros from wiki engines, without their complexity. All of this becomes possible, thanks to mkdocs-macros-plugin !","title":"Solution 3: Enter Macros"}]}